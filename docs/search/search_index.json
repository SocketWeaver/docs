{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SWNetwork SDK Overview Learn how to use SWNetwork, our SDK for the Unity game engine that helps Unity game developers to quickly integrate SocketWeaver backend services into their games. SWNetwork SDK provides a simple API and customized Unity Editor tools you need to create multiplayer games. You can tailor your integration and create various types of networked games, including: Shooters Moba RPG Simulation Turn-based SocketWeaver does not have services for managing user profiles. You need to use services like Google Firebase to persist user data. Get start The tutorials are step-by-step walkthroughs that help you get started with the SWNetwork SDK. Questions? We are here to help. Join us on Discord: https://discord.gg/qXt7Bkf YouTube tutorial videos We upload every Sunday. Our YouTube Channel: https://www.youtube.com/channel/UCvhOf06L9O9Uf1lqWt-USKA","title":"SWNetwork SDK"},{"location":"#swnetwork-sdk-overview","text":"Learn how to use SWNetwork, our SDK for the Unity game engine that helps Unity game developers to quickly integrate SocketWeaver backend services into their games. SWNetwork SDK provides a simple API and customized Unity Editor tools you need to create multiplayer games. You can tailor your integration and create various types of networked games, including: Shooters Moba RPG Simulation Turn-based SocketWeaver does not have services for managing user profiles. You need to use services like Google Firebase to persist user data.","title":"SWNetwork SDK Overview"},{"location":"#get-start","text":"The tutorials are step-by-step walkthroughs that help you get started with the SWNetwork SDK.","title":"Get start"},{"location":"#questions","text":"We are here to help. Join us on Discord: https://discord.gg/qXt7Bkf","title":"Questions?"},{"location":"#youtube-tutorial-videos","text":"We upload every Sunday. Our YouTube Channel: https://www.youtube.com/channel/UCvhOf06L9O9Uf1lqWt-USKA","title":"YouTube tutorial videos"},{"location":"installation/","text":"Custom Unity Package This guide covers how to install the SWNetwork custom package in Unity. Download The SWNetwork.unitypackage can be found on the SDK download page. https://www.socketweaver.com/download.html Install the SWNetwork.unitypackage Installing the package is simple using Unity Editor. Select Assets - Import Package - Custom Package.. Choose SWNetwork.unitypackage in your local file system. Select all the items in the Import Unity Package window and click Import . Select File - Build Settings - Player Settings... - Other Settings - Configuration and make sure Scripting Runtime Version is set to .NET 4.x Equivalent in the PlayerSettings. SWNetwork libraries will be installed under the SWNetwork directory in you project.","title":"Installation"},{"location":"installation/#custom-unity-package","text":"This guide covers how to install the SWNetwork custom package in Unity.","title":"Custom Unity Package"},{"location":"installation/#download","text":"The SWNetwork.unitypackage can be found on the SDK download page. https://www.socketweaver.com/download.html","title":"Download"},{"location":"installation/#install-the-swnetworkunitypackage","text":"Installing the package is simple using Unity Editor. Select Assets - Import Package - Custom Package.. Choose SWNetwork.unitypackage in your local file system. Select all the items in the Import Unity Package window and click Import . Select File - Build Settings - Player Settings... - Other Settings - Configuration and make sure Scripting Runtime Version is set to .NET 4.x Equivalent in the PlayerSettings. SWNetwork libraries will be installed under the SWNetwork directory in you project.","title":"Install the SWNetwork.unitypackage"},{"location":"tutorials/top-down/installation/","text":"Install the SWNetwork SDK Please follow the steps in the Installation page to install the SWNetwork SDK.","title":"Installation"},{"location":"tutorials/top-down/installation/#install-the-swnetwork-sdk","text":"Please follow the steps in the Installation page to install the SWNetwork SDK.","title":"Install the SWNetwork SDK"},{"location":"tutorials/top-down/introduction/","text":"Top-Down Shooter Requirements Unity 2018.3.4 or later . You can download the latest version of Unity here: https://unity3d.com/get-unity/download A SocketWeaver Account . You can create a SocketWeaver Account for free here: https://portal.socketweaver.com All accounts get 20GB of data for free every month. What we are making In this tutorial, we are going to make a multiplayer top-down shooter. We will show you the process step-by-step. By the time you finished reading this tutorial, you will be ready to start converting your own game or explore more advanced features that our Unity SDK provides. Source Code The source code of this tutorial is hosted at: https://github.com/SocketWeaver/third-person The repository has two Unity Projects: Starter The starter project of the tutorial. It has all the assets you need to complete the tutorial. The Starter Project has one scene: Game scene. Game scene You can use the WASD keys or the Arrow keys to move the cube around. Pressing the Space key makes the cube jump. Mouse movement controls the cube's direction. Mouse Left Click fires bullets. Final The final playable multiplayer game. Community If you have questions about the tutorial, join our Discord server: https://discord.gg/qXt7Bkf","title":"Introduction"},{"location":"tutorials/top-down/introduction/#top-down-shooter","text":"","title":"Top-Down Shooter"},{"location":"tutorials/top-down/introduction/#requirements","text":"Unity 2018.3.4 or later . You can download the latest version of Unity here: https://unity3d.com/get-unity/download A SocketWeaver Account . You can create a SocketWeaver Account for free here: https://portal.socketweaver.com All accounts get 20GB of data for free every month.","title":"Requirements"},{"location":"tutorials/top-down/introduction/#what-we-are-making","text":"In this tutorial, we are going to make a multiplayer top-down shooter. We will show you the process step-by-step. By the time you finished reading this tutorial, you will be ready to start converting your own game or explore more advanced features that our Unity SDK provides.","title":"What we are making"},{"location":"tutorials/top-down/introduction/#source-code","text":"The source code of this tutorial is hosted at: https://github.com/SocketWeaver/third-person","title":"Source Code"},{"location":"tutorials/top-down/introduction/#the-repository-has-two-unity-projects","text":"","title":"The repository has two Unity Projects:"},{"location":"tutorials/top-down/introduction/#starter","text":"The starter project of the tutorial. It has all the assets you need to complete the tutorial. The Starter Project has one scene: Game scene.","title":"Starter"},{"location":"tutorials/top-down/introduction/#game-scene","text":"You can use the WASD keys or the Arrow keys to move the cube around. Pressing the Space key makes the cube jump. Mouse movement controls the cube's direction. Mouse Left Click fires bullets.","title":"Game scene"},{"location":"tutorials/top-down/introduction/#final","text":"The final playable multiplayer game.","title":"Final"},{"location":"tutorials/top-down/introduction/#community","text":"If you have questions about the tutorial, join our Discord server: https://discord.gg/qXt7Bkf","title":"Community"},{"location":"tutorials/top-down/remote-events/","text":"Remote Events 5 - 10 minutes read It's time for some shooting! You might have noticed that the shooting action is not synced. In this section, you will add a remote event to the Player Prefab to sync player actions. RemoteEventAgent Select the Player Prefab. Click the Add Component button and Search \"Agent\", select Remote Event Agent to attach it to the Player GameObject. Click on the Add Remote Event button and set the event name to \"fire\". The event name is used to find and trigger a remote event across different networks. Warning Make sure that remote events in the same RemoteEventAgent have different event names. The SocketWeaver remote events are super charged Unity events. You can invoke them in scripts. You can add listeners to handle them, and when a remote events is invoked, the listeners of the same remote event in different network will be triggered. You need to update the PlayerWeapon.cs script to invoke and handle the \"fire\" event. Add two properties: networkId, and remoteEventAgent. NetworkID networkId ; RemoteEventAgent remoteEventAgent ; Implement the Start() method and initialize the networkId, and remoteEventAgent properties. void Start () { networkId = GetComponent NetworkID (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } Only the source GameObject should receive user inputs, we can use the IsMine property of NetworkID component to find out if the Player GameObject is the source GameObject. void Update () { if ( networkId . IsMine ) { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } } Update the fireBullet() method to invoke the \"fire\" event. We used SWNetworkMessage to send the bullet launch position(vector3) and aim direction (vector3) along with the \"fire\" event. void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); remoteEventAgent . Invoke ( fire , msg ); } Implement the Event Handler method. We used PopVector3() method on the SWNetworkMessage object to obtain the launch position and aim direction of the fire remote event. public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); gun . fireBullet ( position , direction ); } The final version of PlayerWeapon.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b public class PlayerWeapon : MonoBehaviour { // aimable layers public LayerMask layerMask ; \u200b private Vector3 currentLookTarget = Vector3 . zero ; public Gun gun ; \u200b // launch position of bullets public Transform launchPosition ; \u200b NetworkID networkId ; RemoteEventAgent remoteEventAgent ; \u200b private void Start () { networkId = GetComponent NetworkID (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } \u200b void FixedUpdate () { if ( networkId . IsMine ) { // find player s cursor position in the environment RaycastHit hit ; Ray ray = Camera . main . ScreenPointToRay ( Input . mousePosition ); Debug . DrawRay ( ray . origin , ray . direction * 1000 , Color . green ); if ( Physics . Raycast ( ray , out hit , 1000 , layerMask , QueryTriggerInteraction . Ignore )) { if ( hit . point != currentLookTarget ) { currentLookTarget = hit . point ; } } \u200b // ignore cursor position s y value. Vector3 targetPosition = new Vector3 ( hit . point . x , transform . position . y , hit . point . z ); \u200b // calculate player s new rotation Quaternion rotation = Quaternion . LookRotation ( targetPosition - transform . position ); \u200b // lerp transform . rotation = Quaternion . Lerp ( transform . rotation , rotation , Time . deltaTime * 10.0f ); } } \u200b void Update () { if ( networkId . IsMine ) { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } } \u200b void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); remoteEventAgent . Invoke ( fire , msg ); } \u200b public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); gun . FireBullet ( position , direction ); } } Add a listener to the \"fire\" event. Make sure to select the RemoteFire() method under the Dynamic Parameter Section of the methods list. Tip Make sure you applied the changes to the Player Prefab. Double check if the player prefab has been saved correctly by inspecting the Player prefab in the /Assets/prefabs folder. Make sure the RemoteEventAgent is saved and the prefab is enabled. Play Tip Make sure you disabled the Player GameObject in the Hierarchy. You can follow the steps in the last section Test and Play to test out the \"fire\" remote event.","title":"Remote Events"},{"location":"tutorials/top-down/remote-events/#remote-events","text":"5 - 10 minutes read It's time for some shooting! You might have noticed that the shooting action is not synced. In this section, you will add a remote event to the Player Prefab to sync player actions.","title":"Remote Events"},{"location":"tutorials/top-down/remote-events/#remoteeventagent","text":"Select the Player Prefab. Click the Add Component button and Search \"Agent\", select Remote Event Agent to attach it to the Player GameObject. Click on the Add Remote Event button and set the event name to \"fire\". The event name is used to find and trigger a remote event across different networks. Warning Make sure that remote events in the same RemoteEventAgent have different event names. The SocketWeaver remote events are super charged Unity events. You can invoke them in scripts. You can add listeners to handle them, and when a remote events is invoked, the listeners of the same remote event in different network will be triggered. You need to update the PlayerWeapon.cs script to invoke and handle the \"fire\" event. Add two properties: networkId, and remoteEventAgent. NetworkID networkId ; RemoteEventAgent remoteEventAgent ; Implement the Start() method and initialize the networkId, and remoteEventAgent properties. void Start () { networkId = GetComponent NetworkID (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } Only the source GameObject should receive user inputs, we can use the IsMine property of NetworkID component to find out if the Player GameObject is the source GameObject. void Update () { if ( networkId . IsMine ) { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } } Update the fireBullet() method to invoke the \"fire\" event. We used SWNetworkMessage to send the bullet launch position(vector3) and aim direction (vector3) along with the \"fire\" event. void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); remoteEventAgent . Invoke ( fire , msg ); } Implement the Event Handler method. We used PopVector3() method on the SWNetworkMessage object to obtain the launch position and aim direction of the fire remote event. public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); gun . fireBullet ( position , direction ); } The final version of PlayerWeapon.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b public class PlayerWeapon : MonoBehaviour { // aimable layers public LayerMask layerMask ; \u200b private Vector3 currentLookTarget = Vector3 . zero ; public Gun gun ; \u200b // launch position of bullets public Transform launchPosition ; \u200b NetworkID networkId ; RemoteEventAgent remoteEventAgent ; \u200b private void Start () { networkId = GetComponent NetworkID (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } \u200b void FixedUpdate () { if ( networkId . IsMine ) { // find player s cursor position in the environment RaycastHit hit ; Ray ray = Camera . main . ScreenPointToRay ( Input . mousePosition ); Debug . DrawRay ( ray . origin , ray . direction * 1000 , Color . green ); if ( Physics . Raycast ( ray , out hit , 1000 , layerMask , QueryTriggerInteraction . Ignore )) { if ( hit . point != currentLookTarget ) { currentLookTarget = hit . point ; } } \u200b // ignore cursor position s y value. Vector3 targetPosition = new Vector3 ( hit . point . x , transform . position . y , hit . point . z ); \u200b // calculate player s new rotation Quaternion rotation = Quaternion . LookRotation ( targetPosition - transform . position ); \u200b // lerp transform . rotation = Quaternion . Lerp ( transform . rotation , rotation , Time . deltaTime * 10.0f ); } } \u200b void Update () { if ( networkId . IsMine ) { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } } \u200b void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); remoteEventAgent . Invoke ( fire , msg ); } \u200b public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); gun . FireBullet ( position , direction ); } } Add a listener to the \"fire\" event. Make sure to select the RemoteFire() method under the Dynamic Parameter Section of the methods list. Tip Make sure you applied the changes to the Player Prefab. Double check if the player prefab has been saved correctly by inspecting the Player prefab in the /Assets/prefabs folder. Make sure the RemoteEventAgent is saved and the prefab is enabled.","title":"RemoteEventAgent"},{"location":"tutorials/top-down/remote-events/#play","text":"Tip Make sure you disabled the Player GameObject in the Hierarchy. You can follow the steps in the last section Test and Play to test out the \"fire\" remote event.","title":"Play"},{"location":"tutorials/top-down/set-up-the-networkclient/","text":"Setting up the NetworkClient 1 - 3 minutes read LobbyScene For simplicity, you are going to use the example LobbyScene included in the SWNetwork package for this tutorial. The LobbyScene is located at Assets/SWNetwork/Scenes/LobbyScene . The LobbyScene uses the JoinOrCreate() method to get players into rooms quickly. SWNetwork has a rich set of APIs to use for matchmaking. If you want to extend the matchmaking logic of your game further, please visit the Lobby API documentation . Set up the NetworkClient NetworkClient is the entry point of your game to interact with the SocketWeaver backend services. You must have one and only one NetworkClient active in your Scene. In the LobbyScene hierarchy, select the NetworkClient GameObject. You will notice that a NetworkClient component is attached to it. NetworkClient has a few properties you can change. For now, you just need to configure its API_KEY property to get your game running. Go to SocketWeaver Developer Portal , and create a new game. Click the Copy button to copy the API key to your clipboard, paste it into the API_KEY textfield of the NetworkClient Component. To test if everything is working correctly, you can play the LobbyScene. The game view should look like the screenshot below. If you leave the custom playerId input field empty, LobbyScene will use a randomly generated unique playerId to check into the SocketWeaver services. The generated playerId will be stored in your computer's hard drive, so if you stop playing and play again, the same playerId will be used. The playerId is used to identify a client in the lobby servers and game servers. By clicking the Register button, the LobbyScene sends a request to SocketWeaver, SocketWeaver will validate the API_KEY and route players to a lobby cluster that is geographically closest to them. Once a player is connected to the assigned lobby cluster, the LobbyScene will automatically register the player to the lobby cluster. The Play button should replace the Register button now. By clicking the Play button, the LobbyScene will try to find a room for the player or create a new room if it cannot find a room in the lobby cluster. By default, when a player is connected to the room's game server, the LobbyScene will load the scene at index 1. You can update it to load the Game scene. void HandleConnectedToRoom ( bool connected ) { if ( connected ) { Debug . Log ( Connected to room ); SceneManager . LoadScene ( game ); } else { Debug . Log ( Failed to connect to room ); } }","title":"Setting up the NetworkClient"},{"location":"tutorials/top-down/set-up-the-networkclient/#setting-up-the-networkclient","text":"1 - 3 minutes read","title":"Setting up the NetworkClient"},{"location":"tutorials/top-down/set-up-the-networkclient/#lobbyscene","text":"For simplicity, you are going to use the example LobbyScene included in the SWNetwork package for this tutorial. The LobbyScene is located at Assets/SWNetwork/Scenes/LobbyScene . The LobbyScene uses the JoinOrCreate() method to get players into rooms quickly. SWNetwork has a rich set of APIs to use for matchmaking. If you want to extend the matchmaking logic of your game further, please visit the Lobby API documentation .","title":"LobbyScene"},{"location":"tutorials/top-down/set-up-the-networkclient/#set-up-the-networkclient","text":"NetworkClient is the entry point of your game to interact with the SocketWeaver backend services. You must have one and only one NetworkClient active in your Scene. In the LobbyScene hierarchy, select the NetworkClient GameObject. You will notice that a NetworkClient component is attached to it. NetworkClient has a few properties you can change. For now, you just need to configure its API_KEY property to get your game running. Go to SocketWeaver Developer Portal , and create a new game. Click the Copy button to copy the API key to your clipboard, paste it into the API_KEY textfield of the NetworkClient Component. To test if everything is working correctly, you can play the LobbyScene. The game view should look like the screenshot below. If you leave the custom playerId input field empty, LobbyScene will use a randomly generated unique playerId to check into the SocketWeaver services. The generated playerId will be stored in your computer's hard drive, so if you stop playing and play again, the same playerId will be used. The playerId is used to identify a client in the lobby servers and game servers. By clicking the Register button, the LobbyScene sends a request to SocketWeaver, SocketWeaver will validate the API_KEY and route players to a lobby cluster that is geographically closest to them. Once a player is connected to the assigned lobby cluster, the LobbyScene will automatically register the player to the lobby cluster. The Play button should replace the Register button now. By clicking the Play button, the LobbyScene will try to find a room for the player or create a new room if it cannot find a room in the lobby cluster. By default, when a player is connected to the room's game server, the LobbyScene will load the scene at index 1. You can update it to load the Game scene. void HandleConnectedToRoom ( bool connected ) { if ( connected ) { Debug . Log ( Connected to room ); SceneManager . LoadScene ( game ); } else { Debug . Log ( Failed to connect to room ); } }","title":"Set up the NetworkClient"},{"location":"tutorials/top-down/set-up-the-scenespawner/","text":"Setting up the Scene Spawner 5 - 10 minutes read Player Prefab At this point, you have the Player RealTimeAgent set up. Select the Player GameObject in the Scene Hierarchy and drag it into the Prefabs folder in the Project Assets folder. SceneSpawner Add a new Empty GameObject and name it SceneSpawner . Click the Add Component button and Search \"Spawner\", select SceneSpawner to attach it to the new GameObject. Note that a NetworkSystemID component was attached to SceneSpawner GameObject automatically. NetworkSystemID component help SWNetwork to identify SWNetwork's internal GameObjects. Choose a unique Spawner Id The SceneSpawner instantiates and destroys Networked GameObjects in a Scene(GameObjects that have a NetworkID component). Make sure you give different SpawnerId to different **SceneSpawner**s. Our game only has one SceneSpawner , we can set its SpawnerId to 1. Creating Spawn Points Create an Empty GameObject and name it SpawnPoints , reset its position to (0, 0, 0). Create an Empty GameObject and name it SpawnPoint , and reset its position to (0, 0, 0)as well. Select an Icon for the SpawnPoint so we can easily find it in the Scene. Select the SpawnPoint GameObject in the Hierarchy and drag it into the Prefabs Folder to create a SpawnPoint Prefab. Drag the SpawnPoint prefab into the SpawnPoints GameObject and create 4 SpawnPoints . Move the **SpawnPoint**s to the places you like to spawn the players. Set the Position Y to 1.5 to make sure the players are spawned above the ground. Select the SceneSpawner GameObject, open the Spawn Point section and set the Size to 4. Drag the SpawnPoint into the slots. Adding the Player Prefab to the Scene Spawner Open the Player Prefabs section of the SceneSpawner, drag the Player Prefab into it. Handling the SceneSpawner OnReady Event Open the GameSceneManager.cs script, and add a method to handle the OnReadyEvent of the SceneSpawner. Your GameSceneManager.cs script should look like: using UnityEngine.SceneManagement ; using UnityEngine ; using SWNetwork ; \u200b /// summary /// Game scene manager manages game scenes state. /// /summary public class GameSceneManager : MonoBehaviour { public GameObject winnerPanel ; public GameObject gameOverPanel ; \u200b public void Exit () { // TODO // exit the game } \u200b // OnSpawnerReady(bool alreadySetup) method is added to handle the On Ready Event. public void OnSpawnerReady ( bool alreadySetup ) { Debug . Log ( OnSpawnerReady + alreadySetup ); \u200b // Check alreadySetup to see if the scene has been set up before. // If it is true, it means the player disconnected and reconnected to the game. // In this case, we should not spawn a new Player GameObject for the player. if (! alreadySetup ) { // If alreadySetup is false, it means the player just started the game. // We randomly select a SpawnPoint and ask the SceneSpawner to spawn a Player GameObject. // we have 1 playerPrefabs so playerPrefabIndex is 0. // We have 4 spawnPoints so we generated a random int between 0 to 3. int spawnPointIndex = Random . Range ( 0 , 3 ); NetworkClient . Instance . LastSpawner . SpawnForPlayer ( 0 , spawnPointIndex ); \u200b // Tell the spawner that we have finished setting up the scene. // alreadySetup will be true when SceneSpawn becomes ready next time. NetworkClient . Instance . LastSpawner . PlayerFinishedSceneSetup (); } } } In the SceneSpawner component, add a listener to the On Ready event. Select OnSpawnerReady(bool) in the GameSceneManager.cs script. Make sure to select the OnSpawnerReady method from the Dynamic bool section in the list..","title":"Setting up the SceneSpawner"},{"location":"tutorials/top-down/set-up-the-scenespawner/#setting-up-the-scene-spawner","text":"5 - 10 minutes read","title":"Setting up the Scene Spawner"},{"location":"tutorials/top-down/set-up-the-scenespawner/#player-prefab","text":"At this point, you have the Player RealTimeAgent set up. Select the Player GameObject in the Scene Hierarchy and drag it into the Prefabs folder in the Project Assets folder.","title":"Player Prefab"},{"location":"tutorials/top-down/set-up-the-scenespawner/#scenespawner","text":"Add a new Empty GameObject and name it SceneSpawner . Click the Add Component button and Search \"Spawner\", select SceneSpawner to attach it to the new GameObject. Note that a NetworkSystemID component was attached to SceneSpawner GameObject automatically. NetworkSystemID component help SWNetwork to identify SWNetwork's internal GameObjects.","title":"SceneSpawner"},{"location":"tutorials/top-down/set-up-the-scenespawner/#choose-a-unique-spawner-id","text":"The SceneSpawner instantiates and destroys Networked GameObjects in a Scene(GameObjects that have a NetworkID component). Make sure you give different SpawnerId to different **SceneSpawner**s. Our game only has one SceneSpawner , we can set its SpawnerId to 1.","title":"Choose a unique Spawner Id"},{"location":"tutorials/top-down/set-up-the-scenespawner/#creating-spawn-points","text":"Create an Empty GameObject and name it SpawnPoints , reset its position to (0, 0, 0). Create an Empty GameObject and name it SpawnPoint , and reset its position to (0, 0, 0)as well. Select an Icon for the SpawnPoint so we can easily find it in the Scene. Select the SpawnPoint GameObject in the Hierarchy and drag it into the Prefabs Folder to create a SpawnPoint Prefab. Drag the SpawnPoint prefab into the SpawnPoints GameObject and create 4 SpawnPoints . Move the **SpawnPoint**s to the places you like to spawn the players. Set the Position Y to 1.5 to make sure the players are spawned above the ground. Select the SceneSpawner GameObject, open the Spawn Point section and set the Size to 4. Drag the SpawnPoint into the slots. Adding the Player Prefab to the Scene Spawner Open the Player Prefabs section of the SceneSpawner, drag the Player Prefab into it.","title":"Creating Spawn Points"},{"location":"tutorials/top-down/set-up-the-scenespawner/#handling-the-scenespawner-onready-event","text":"Open the GameSceneManager.cs script, and add a method to handle the OnReadyEvent of the SceneSpawner. Your GameSceneManager.cs script should look like: using UnityEngine.SceneManagement ; using UnityEngine ; using SWNetwork ; \u200b /// summary /// Game scene manager manages game scenes state. /// /summary public class GameSceneManager : MonoBehaviour { public GameObject winnerPanel ; public GameObject gameOverPanel ; \u200b public void Exit () { // TODO // exit the game } \u200b // OnSpawnerReady(bool alreadySetup) method is added to handle the On Ready Event. public void OnSpawnerReady ( bool alreadySetup ) { Debug . Log ( OnSpawnerReady + alreadySetup ); \u200b // Check alreadySetup to see if the scene has been set up before. // If it is true, it means the player disconnected and reconnected to the game. // In this case, we should not spawn a new Player GameObject for the player. if (! alreadySetup ) { // If alreadySetup is false, it means the player just started the game. // We randomly select a SpawnPoint and ask the SceneSpawner to spawn a Player GameObject. // we have 1 playerPrefabs so playerPrefabIndex is 0. // We have 4 spawnPoints so we generated a random int between 0 to 3. int spawnPointIndex = Random . Range ( 0 , 3 ); NetworkClient . Instance . LastSpawner . SpawnForPlayer ( 0 , spawnPointIndex ); \u200b // Tell the spawner that we have finished setting up the scene. // alreadySetup will be true when SceneSpawn becomes ready next time. NetworkClient . Instance . LastSpawner . PlayerFinishedSceneSetup (); } } } In the SceneSpawner component, add a listener to the On Ready event. Select OnSpawnerReady(bool) in the GameSceneManager.cs script. Make sure to select the OnSpawnerReady method from the Dynamic bool section in the list..","title":"Handling the SceneSpawner OnReady Event"},{"location":"tutorials/top-down/sync-player-transform/","text":"Sync Player Transform 3 - 5 minutes read RealTime Agent Open the game scene, select the Player GameObject in the Hierarchy. Click the Add Component button and Search \"Agent\", select Realtime Agent to attach it to the Player GameObject. You will see that a NetworkID component was attached to Player GameObject automatically. NetworkID component helps SWNetwork to identify a GameObject. Set its Type to Player as the GameObject will be controlled by the players. \u200b Position The RealTimeAgent send GameObject's position, rotation updates to its remote duplicates. The Player GameObject moves in X, Y, Z directions, so we need to enable all of them. The Min , Max , and Resolution settings are used to compress the X, Y, Z values. In this game, the player moves between -20 to 20 in the X-axis, 0 to 3 in the Y-axis, and -20 to 20 in the Z-axis. You can use these limits to set the compression settings. Rotation The Player GameObject rotates around the Y-axis. We should enable Y for Rotation. We can set the resolution to Ten as we do not need high precision for rotation. The Y rotation value that remote duplicates receive will be like: 0, 10, 20 ... 360. The Interpolate field controls the interpolation of rotation and scale updates. The larger the number the faster the GameObject interpolates to the target rotation and scale. The Smooth Level field controls the smoothness of position updates. The larger the number the smoother the GameObject moves to the target position. However, a larger smooth level will affect the GameObjects responsiveness. The Read Function field controls in which function the remote duplicates will read the position updates. You can use the settings in the below screenshot to config the RealTime Agent. Updating the PlayerMovement.cs script You need to update the PlayerMovement.cs script so that only the source Player GameObject receives user inputs. Use the IsMine property of NetworkID to find out if the Player GameObject is the source GameObject. Also, set the camera to follow the source Player GameObject. The PlayerMovement.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b /// summary /// Player movement. /// /summary public class PlayerMovement : MonoBehaviour { public float moveSpeed = 6.0F ; public float gravity = - 15f ; private float verticalVelocity ; public float jumpForce = 7.0f ; \u200b private CharacterController characterController ; \u200b NetworkID networkId ; \u200b void Start () { characterController = GetComponent CharacterController (); networkId = GetComponent NetworkID (); \u200b if ( networkId . IsMine ) { // set CameraFollow target Camera m_MainCamera = Camera . main ; CameraFollow cameraFollow = m_MainCamera . GetComponent CameraFollow (); cameraFollow . target = gameObject ; } } \u200b void Update () { if ( networkId . IsMine ) { // get keyboard inputs float speedX = Input . GetAxis ( Horizontal ) * moveSpeed ; float speedZ = Input . GetAxis ( Vertical ) * moveSpeed ; \u200b if ( characterController . isGrounded ) { verticalVelocity = gravity ; if ( Input . GetKeyDown ( KeyCode . Space )) { Jump (); } } else { verticalVelocity += gravity * Time . deltaTime ; } \u200b Vector3 movement = new Vector3 ( speedX , verticalVelocity , speedZ ); characterController . Move ( movement * Time . deltaTime ); } } \u200b public void Jump () { verticalVelocity = jumpForce ; } } Updating the PlayerWeapon.cs script Make sure only the GameObject that the local player owns receives mouse movement as well. The PlayerWeapon.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b public class PlayerWeapon : MonoBehaviour { // aimable layers public LayerMask layerMask ; \u200b private Vector3 currentLookTarget = Vector3 . zero ; public Gun gun ; \u200b // launch position of bulletes public Transform launchPosition ; \u200b NetworkID networkId ; \u200b private void Start () { networkId = GetComponent NetworkID (); } \u200b void FixedUpdate () { if ( networkId . IsMine ) { // find player s cursor position in the environment RaycastHit hit ; Ray ray = Camera . main . ScreenPointToRay ( Input . mousePosition ); Debug . DrawRay ( ray . origin , ray . direction * 1000 , Color . green ); if ( Physics . Raycast ( ray , out hit , 1000 , layerMask , QueryTriggerInteraction . Ignore )) { if ( hit . point != currentLookTarget ) { currentLookTarget = hit . point ; } } \u200b // ignore cursor position s y value. Vector3 targetPosition = new Vector3 ( hit . point . x , transform . position . y , hit . point . z ); \u200b // calculate player s new rotation Quaternion rotation = Quaternion . LookRotation ( targetPosition - transform . position ); \u200b // lerp transform . rotation = Quaternion . Lerp ( transform . rotation , rotation , Time . deltaTime * 10.0f ); } } \u200b void Update () { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } \u200b void FireBullet () { gun . FireBullet ( launchPosition . position , transform . forward ); } }","title":"Sync Player Transfrom"},{"location":"tutorials/top-down/sync-player-transform/#sync-player-transform","text":"3 - 5 minutes read","title":"Sync Player Transform"},{"location":"tutorials/top-down/sync-player-transform/#realtime-agent","text":"Open the game scene, select the Player GameObject in the Hierarchy. Click the Add Component button and Search \"Agent\", select Realtime Agent to attach it to the Player GameObject. You will see that a NetworkID component was attached to Player GameObject automatically. NetworkID component helps SWNetwork to identify a GameObject. Set its Type to Player as the GameObject will be controlled by the players. \u200b","title":"RealTime Agent"},{"location":"tutorials/top-down/sync-player-transform/#position","text":"The RealTimeAgent send GameObject's position, rotation updates to its remote duplicates. The Player GameObject moves in X, Y, Z directions, so we need to enable all of them. The Min , Max , and Resolution settings are used to compress the X, Y, Z values. In this game, the player moves between -20 to 20 in the X-axis, 0 to 3 in the Y-axis, and -20 to 20 in the Z-axis. You can use these limits to set the compression settings.","title":"Position"},{"location":"tutorials/top-down/sync-player-transform/#rotation","text":"The Player GameObject rotates around the Y-axis. We should enable Y for Rotation. We can set the resolution to Ten as we do not need high precision for rotation. The Y rotation value that remote duplicates receive will be like: 0, 10, 20 ... 360. The Interpolate field controls the interpolation of rotation and scale updates. The larger the number the faster the GameObject interpolates to the target rotation and scale. The Smooth Level field controls the smoothness of position updates. The larger the number the smoother the GameObject moves to the target position. However, a larger smooth level will affect the GameObjects responsiveness. The Read Function field controls in which function the remote duplicates will read the position updates. You can use the settings in the below screenshot to config the RealTime Agent.","title":"Rotation"},{"location":"tutorials/top-down/sync-player-transform/#updating-the-playermovementcs-script","text":"You need to update the PlayerMovement.cs script so that only the source Player GameObject receives user inputs. Use the IsMine property of NetworkID to find out if the Player GameObject is the source GameObject. Also, set the camera to follow the source Player GameObject. The PlayerMovement.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b /// summary /// Player movement. /// /summary public class PlayerMovement : MonoBehaviour { public float moveSpeed = 6.0F ; public float gravity = - 15f ; private float verticalVelocity ; public float jumpForce = 7.0f ; \u200b private CharacterController characterController ; \u200b NetworkID networkId ; \u200b void Start () { characterController = GetComponent CharacterController (); networkId = GetComponent NetworkID (); \u200b if ( networkId . IsMine ) { // set CameraFollow target Camera m_MainCamera = Camera . main ; CameraFollow cameraFollow = m_MainCamera . GetComponent CameraFollow (); cameraFollow . target = gameObject ; } } \u200b void Update () { if ( networkId . IsMine ) { // get keyboard inputs float speedX = Input . GetAxis ( Horizontal ) * moveSpeed ; float speedZ = Input . GetAxis ( Vertical ) * moveSpeed ; \u200b if ( characterController . isGrounded ) { verticalVelocity = gravity ; if ( Input . GetKeyDown ( KeyCode . Space )) { Jump (); } } else { verticalVelocity += gravity * Time . deltaTime ; } \u200b Vector3 movement = new Vector3 ( speedX , verticalVelocity , speedZ ); characterController . Move ( movement * Time . deltaTime ); } } \u200b public void Jump () { verticalVelocity = jumpForce ; } }","title":"Updating the PlayerMovement.cs script"},{"location":"tutorials/top-down/sync-player-transform/#updating-the-playerweaponcs-script","text":"Make sure only the GameObject that the local player owns receives mouse movement as well. The PlayerWeapon.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b public class PlayerWeapon : MonoBehaviour { // aimable layers public LayerMask layerMask ; \u200b private Vector3 currentLookTarget = Vector3 . zero ; public Gun gun ; \u200b // launch position of bulletes public Transform launchPosition ; \u200b NetworkID networkId ; \u200b private void Start () { networkId = GetComponent NetworkID (); } \u200b void FixedUpdate () { if ( networkId . IsMine ) { // find player s cursor position in the environment RaycastHit hit ; Ray ray = Camera . main . ScreenPointToRay ( Input . mousePosition ); Debug . DrawRay ( ray . origin , ray . direction * 1000 , Color . green ); if ( Physics . Raycast ( ray , out hit , 1000 , layerMask , QueryTriggerInteraction . Ignore )) { if ( hit . point != currentLookTarget ) { currentLookTarget = hit . point ; } } \u200b // ignore cursor position s y value. Vector3 targetPosition = new Vector3 ( hit . point . x , transform . position . y , hit . point . z ); \u200b // calculate player s new rotation Quaternion rotation = Quaternion . LookRotation ( targetPosition - transform . position ); \u200b // lerp transform . rotation = Quaternion . Lerp ( transform . rotation , rotation , Time . deltaTime * 10.0f ); } } \u200b void Update () { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } \u200b void FireBullet () { gun . FireBullet ( launchPosition . position , transform . forward ); } }","title":"Updating the PlayerWeapon.cs script"},{"location":"tutorials/top-down/sync-properties/","text":"SyncProperties 5 - 10 minutes read In this section, you will use SyncProperty to update player's hp. Why using SyncProperty SyncProperties are designed for updating states that are not constantly changing. Only send/receive when the property updates Reliable Supports serializable objects Supports user-defined classes and structs. Supports conflict resolution SyncPropertyAgent Select the Player Prefab. Click the Add Component button and Search \"Agent\", select Sync Property Agent to attach it to the Player GameObject. Click the Add Sync Property button to create a SyncProperty for the Player. The Property's name is important and has to be unique in the same SyncPropertyAgent component. Set Name to \"hp\" and set Type to Int . The Conflict Resolution rule is default to Mine . You can use Mine for this tutorial. For more information on Conflict Resolution, please visit [Conflict Resolution]. Updating the PlayerHP.cs Script Add two properties: networkId, and syncPropertyAgent. NetworkID networkId ; SyncPropertyAgent syncPropertyAgent ; You can remove the currentHP property as the player hp will be stored in the \"hp\" SyncProperty. In the Start() method, and initialize the networkId, and syncPropertyAgent void Start () { networkId = GetComponent NetworkID (); syncPropertyAgent = gameObject . GetComponent SyncPropertyAgent (); } Handling the OnReady SyncProperty Event public void OnHPReady () { Debug . Log ( OnHPPropertyReady ); \u200b // Get the current value of the hp SyncProperty. currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the local player has ownership of the GameObject. // Source GameObject can modify the hp SyncProperty. // Remote duplicates should only be able to read the hp SyncProperty. if ( networkId . IsMine ) { int version = syncPropertyAgent . GetPropertyWithName ( hp ). version ; \u200b if ( version != 0 ) { // You can check the version of a SyncProperty to see if it has been initialized. // If version is not 0, it means the SyncProperty has been modified before. // Probably the player got disconnected from the game. // Set hpSlider s value to currentHP to restore player s hp. hpSlider . value = currentHP ; } else { // If version is 0, you can call the Modify() method on the SyncPropertyAgent to initialize player s hp to maxHp. syncPropertyAgent . Modify ( hp , maxHp ); hpSlider . value = maxHp ; } } else { hpSlider . value = currentHP ; } } Updating the GotHit() Method public void GotHit ( int damage ) { // Only the source GameObject can modify the hp SyncProperty. if ( networkId . IsMine ) { currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the player is already dead. if ( currentHP == 0 ) { return ; } \u200b Debug . Log ( Got hit: old currentHP= + currentHP ); \u200b if ( currentHP 0 ) { currentHP = currentHP - damage ; // if hp is lower than 0, set it to 0. if ( currentHP 0 ) { currentHP = 0 ; } } \u200b Debug . Log ( Got hit: new currentHP= + currentHP ); \u200b // Apply damage and modify the hp SyncProperty. syncPropertyAgent . Modify ( hp , currentHP ); } } Handling the OnChanged SyncProperty Event public void OnHpChanged () { // Update the hpSlider when player hp changes currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); hpSlider . value = currentHP ; } Adding listeners to the \"hp\" SyncProperty . Tip Make sure you applied the changes to the Player Prefab and disabled the Player GameObject in the Hierarchy. Play You can follow the steps in the Test and Play section to test out the \"hp\" SyncProperty.","title":"SyncProperties"},{"location":"tutorials/top-down/sync-properties/#syncproperties","text":"5 - 10 minutes read In this section, you will use SyncProperty to update player's hp. Why using SyncProperty SyncProperties are designed for updating states that are not constantly changing. Only send/receive when the property updates Reliable Supports serializable objects Supports user-defined classes and structs. Supports conflict resolution","title":"SyncProperties"},{"location":"tutorials/top-down/sync-properties/#syncpropertyagent","text":"Select the Player Prefab. Click the Add Component button and Search \"Agent\", select Sync Property Agent to attach it to the Player GameObject. Click the Add Sync Property button to create a SyncProperty for the Player. The Property's name is important and has to be unique in the same SyncPropertyAgent component. Set Name to \"hp\" and set Type to Int . The Conflict Resolution rule is default to Mine . You can use Mine for this tutorial. For more information on Conflict Resolution, please visit [Conflict Resolution].","title":"SyncPropertyAgent"},{"location":"tutorials/top-down/sync-properties/#updating-the-playerhpcs-script","text":"","title":"Updating the PlayerHP.cs Script"},{"location":"tutorials/top-down/sync-properties/#add-two-properties-networkid-and-syncpropertyagent","text":"NetworkID networkId ; SyncPropertyAgent syncPropertyAgent ; You can remove the currentHP property as the player hp will be stored in the \"hp\" SyncProperty.","title":"Add two properties: networkId, and syncPropertyAgent."},{"location":"tutorials/top-down/sync-properties/#in-the-start-method-and-initialize-the-networkid-and-syncpropertyagent","text":"void Start () { networkId = GetComponent NetworkID (); syncPropertyAgent = gameObject . GetComponent SyncPropertyAgent (); }","title":"In the Start() method, and initialize the networkId, and syncPropertyAgent"},{"location":"tutorials/top-down/sync-properties/#handling-the-onready-syncproperty-event","text":"public void OnHPReady () { Debug . Log ( OnHPPropertyReady ); \u200b // Get the current value of the hp SyncProperty. currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the local player has ownership of the GameObject. // Source GameObject can modify the hp SyncProperty. // Remote duplicates should only be able to read the hp SyncProperty. if ( networkId . IsMine ) { int version = syncPropertyAgent . GetPropertyWithName ( hp ). version ; \u200b if ( version != 0 ) { // You can check the version of a SyncProperty to see if it has been initialized. // If version is not 0, it means the SyncProperty has been modified before. // Probably the player got disconnected from the game. // Set hpSlider s value to currentHP to restore player s hp. hpSlider . value = currentHP ; } else { // If version is 0, you can call the Modify() method on the SyncPropertyAgent to initialize player s hp to maxHp. syncPropertyAgent . Modify ( hp , maxHp ); hpSlider . value = maxHp ; } } else { hpSlider . value = currentHP ; } }","title":"Handling the OnReady SyncProperty Event"},{"location":"tutorials/top-down/sync-properties/#updating-the-gothit-method","text":"public void GotHit ( int damage ) { // Only the source GameObject can modify the hp SyncProperty. if ( networkId . IsMine ) { currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the player is already dead. if ( currentHP == 0 ) { return ; } \u200b Debug . Log ( Got hit: old currentHP= + currentHP ); \u200b if ( currentHP 0 ) { currentHP = currentHP - damage ; // if hp is lower than 0, set it to 0. if ( currentHP 0 ) { currentHP = 0 ; } } \u200b Debug . Log ( Got hit: new currentHP= + currentHP ); \u200b // Apply damage and modify the hp SyncProperty. syncPropertyAgent . Modify ( hp , currentHP ); } }","title":"Updating the GotHit() Method"},{"location":"tutorials/top-down/sync-properties/#handling-the-onchanged-syncproperty-event","text":"public void OnHpChanged () { // Update the hpSlider when player hp changes currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); hpSlider . value = currentHP ; }","title":"Handling the OnChanged SyncProperty Event"},{"location":"tutorials/top-down/sync-properties/#adding-listeners-to-the-hp-syncproperty","text":"Tip Make sure you applied the changes to the Player Prefab and disabled the Player GameObject in the Hierarchy.","title":"Adding listeners to the \"hp\" SyncProperty."},{"location":"tutorials/top-down/sync-properties/#play","text":"You can follow the steps in the Test and Play section to test out the \"hp\" SyncProperty.","title":"Play"},{"location":"tutorials/top-down/test-and-play/","text":"Test and Play 3 - 5 minutes read At this point, you have set up the Player prefab, configured the SceneSpawner , and updated the LobbyScene to load the Game Scene. It's time to have some fun now. Let's build the game and test out what we have created so far. Disable the Player GameObject in the Game Scene Hierarchy as we want the SceneSpawner to create the Players. Custom Player Id SWNetwork generates unique playerId for each game installation. This is for SocketWeaver to identify a client. If you call the NetworkClient.Instance.CheckIn() method, the generated playerId will be used to check the client into the SocketWeaver services. Tip The first line in the black box is the generated playerId: a9d91dbd-64... If you use services like Google Firebase to manage user profiles, you can call the NetworkClient.Instance.CheckIn(customPlayerId) method to overide the generated playerId. Tip You can use the NetworkClient.Instance.CheckIn(customPlayerId) method for development testing as well. Build and Run Select Build Settings... Make sure you have added the welcome scene and game scene to the game. The welcome scene should have index 0 . The game scene should have index 1 . Select Build to build the game. In the Game Configuration window, select the resolution and the Graphics quality you like and enable Windowed . Click on the Play! button to start the game. The game should launch to the LobbyScene. Enter \"player1\" as the custom playerId and click the Register blue button. You should see the Play button replaces the Register button indicating that you have successfully checked-in and are ready to join or create rooms. Click the Play button to join or create a room. As there is no room on the lobby server for your game, the local player \"player1\" will create a new room on the lobby server and become the owner of the new room. The matchmaking logic of the LobbyScene will automatically start the room and connect to the room game server once it is ready. The game should load the game scene now. Running another client in the Unity Editor In the Unity Editor, load the LobbyScene and hit play . Enter \"player2\" as the custom player Id and click the Register blue button. Notice the playerId in the NetworkClient is overridden by the custom playerId you entered. Click the Play blue button, the \"player2\" client will try to join or create a room. It will find the room that \"player1\" created. Since the room has already started, \"player2\" will automatically connect to the room game server and load the game scene. Now you can move around in the scene and try to find \"player1\"! Success Congratulations! You found \"player1\".","title":"Test and Play"},{"location":"tutorials/top-down/test-and-play/#test-and-play","text":"3 - 5 minutes read At this point, you have set up the Player prefab, configured the SceneSpawner , and updated the LobbyScene to load the Game Scene. It's time to have some fun now. Let's build the game and test out what we have created so far. Disable the Player GameObject in the Game Scene Hierarchy as we want the SceneSpawner to create the Players.","title":"Test and Play"},{"location":"tutorials/top-down/test-and-play/#custom-player-id","text":"SWNetwork generates unique playerId for each game installation. This is for SocketWeaver to identify a client. If you call the NetworkClient.Instance.CheckIn() method, the generated playerId will be used to check the client into the SocketWeaver services. Tip The first line in the black box is the generated playerId: a9d91dbd-64... If you use services like Google Firebase to manage user profiles, you can call the NetworkClient.Instance.CheckIn(customPlayerId) method to overide the generated playerId. Tip You can use the NetworkClient.Instance.CheckIn(customPlayerId) method for development testing as well.","title":"Custom Player Id"},{"location":"tutorials/top-down/test-and-play/#build-and-run","text":"Select Build Settings... Make sure you have added the welcome scene and game scene to the game. The welcome scene should have index 0 . The game scene should have index 1 . Select Build to build the game. In the Game Configuration window, select the resolution and the Graphics quality you like and enable Windowed . Click on the Play! button to start the game. The game should launch to the LobbyScene. Enter \"player1\" as the custom playerId and click the Register blue button. You should see the Play button replaces the Register button indicating that you have successfully checked-in and are ready to join or create rooms. Click the Play button to join or create a room. As there is no room on the lobby server for your game, the local player \"player1\" will create a new room on the lobby server and become the owner of the new room. The matchmaking logic of the LobbyScene will automatically start the room and connect to the room game server once it is ready. The game should load the game scene now.","title":"Build and Run"},{"location":"tutorials/top-down/test-and-play/#running-another-client-in-the-unity-editor","text":"In the Unity Editor, load the LobbyScene and hit play . Enter \"player2\" as the custom player Id and click the Register blue button. Notice the playerId in the NetworkClient is overridden by the custom playerId you entered. Click the Play blue button, the \"player2\" client will try to join or create a room. It will find the room that \"player1\" created. Since the room has already started, \"player2\" will automatically connect to the room game server and load the game scene. Now you can move around in the scene and try to find \"player1\"! Success Congratulations! You found \"player1\".","title":"Running another client in the Unity Editor"}]}