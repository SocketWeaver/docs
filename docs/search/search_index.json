{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SWNetwork SDK Overview Learn how to use SWNetwork, our SDK for the Unity game engine that helps Unity game developers to quickly integrate SocketWeaver backend services into their games. SWNetwork SDK provides a simple API and customized Unity Editor tools you need to create multiplayer games. You can tailor your integration and create various types of networked games, including: Shooters Moba RPG Simulation Turn-based SocketWeaver does not have services for managing user profiles. You need to use services like Google Firebase to persist user data. Get start The tutorials are step-by-step walkthroughs that help you get started with the SWNetwork SDK. Questions? We are here to help. Join us on Discord: https://discord.gg/qXt7Bkf YouTube tutorial videos We upload every Sunday. Our YouTube Channel: https://www.youtube.com/channel/UCvhOf06L9O9Uf1lqWt-USKA","title":"SWNetwork SDK"},{"location":"#swnetwork-sdk-overview","text":"Learn how to use SWNetwork, our SDK for the Unity game engine that helps Unity game developers to quickly integrate SocketWeaver backend services into their games. SWNetwork SDK provides a simple API and customized Unity Editor tools you need to create multiplayer games. You can tailor your integration and create various types of networked games, including: Shooters Moba RPG Simulation Turn-based SocketWeaver does not have services for managing user profiles. You need to use services like Google Firebase to persist user data.","title":"SWNetwork SDK Overview"},{"location":"#get-start","text":"The tutorials are step-by-step walkthroughs that help you get started with the SWNetwork SDK.","title":"Get start"},{"location":"#questions","text":"We are here to help. Join us on Discord: https://discord.gg/qXt7Bkf","title":"Questions?"},{"location":"#youtube-tutorial-videos","text":"We upload every Sunday. Our YouTube Channel: https://www.youtube.com/channel/UCvhOf06L9O9Uf1lqWt-USKA","title":"YouTube tutorial videos"},{"location":"installation/","text":"Custom Unity Package This guide covers how to install the SWNetwork custom package in Unity. Download The SWNetwork.unitypackage can be found on the SDK download page. https://www.socketweaver.com/download.html Install the SWNetwork.unitypackage Installing the package is simple using Unity Editor. Select Assets - Import Package - Custom Package.. Choose SWNetwork.unitypackage in your local file system. Select all the items in the Import Unity Package window and click Import . Select File - Build Settings - Player Settings... - Other Settings - Configuration and make sure Scripting Runtime Version is set to .NET 4.x Equivalent in the PlayerSettings. SWNetwork libraries will be installed under the SWNetwork directory in you project.","title":"Installation"},{"location":"installation/#custom-unity-package","text":"This guide covers how to install the SWNetwork custom package in Unity.","title":"Custom Unity Package"},{"location":"installation/#download","text":"The SWNetwork.unitypackage can be found on the SDK download page. https://www.socketweaver.com/download.html","title":"Download"},{"location":"installation/#install-the-swnetworkunitypackage","text":"Installing the package is simple using Unity Editor. Select Assets - Import Package - Custom Package.. Choose SWNetwork.unitypackage in your local file system. Select all the items in the Import Unity Package window and click Import . Select File - Build Settings - Player Settings... - Other Settings - Configuration and make sure Scripting Runtime Version is set to .NET 4.x Equivalent in the PlayerSettings. SWNetwork libraries will be installed under the SWNetwork directory in you project.","title":"Install the SWNetwork.unitypackage"},{"location":"reference/networkclient/classes/networkclient/checkin/","text":"CheckIn() Method Checks into the SocketWeaver services with a random unique playerId. Declaration public void CheckIn () CheckIn(string) Method Checks into the SocketWeaver services with specified playerId. Make sure the playerId is unique. Declaration public void CheckIn ( string customPlayerId ) Parameters Type Description customPlayerId string The customPlayerId","title":"CheckIn()"},{"location":"reference/networkclient/classes/networkclient/checkin/#checkin-method","text":"Checks into the SocketWeaver services with a random unique playerId.","title":"CheckIn() Method"},{"location":"reference/networkclient/classes/networkclient/checkin/#declaration","text":"public void CheckIn ()","title":"Declaration"},{"location":"reference/networkclient/classes/networkclient/checkin/#checkinstring-method","text":"Checks into the SocketWeaver services with specified playerId. Make sure the playerId is unique.","title":"CheckIn(string) Method"},{"location":"reference/networkclient/classes/networkclient/checkin/#declaration_1","text":"public void CheckIn ( string customPlayerId ) Parameters Type Description customPlayerId string The customPlayerId","title":"Declaration"},{"location":"reference/networkclient/classes/networkclient/connecttoroom/","text":"ConnectToRoom(Action ) Method Connects the local player to the room game servers. Declaration public void ConnectToRoom ( Action bool callback ) Parameters Type Description callback Action The method to invoke when the client is connected to the game servers of the room.","title":"ConnectToRoom(Action<bool>)"},{"location":"reference/networkclient/classes/networkclient/connecttoroom/#connecttoroomaction-method","text":"Connects the local player to the room game servers.","title":"ConnectToRoom(Action) Method"},{"location":"reference/networkclient/classes/networkclient/connecttoroom/#declaration","text":"public void ConnectToRoom ( Action bool callback ) Parameters Type Description callback Action The method to invoke when the client is connected to the game servers of the room.","title":"Declaration"},{"location":"reference/networkclient/classes/networkclient/disconnectfromroom/","text":"DisconnectFromRoom() Method Connects the local player to the room game servers. Declaration public void DisconnectFromRoom ();","title":"DisconnectFromRoom()"},{"location":"reference/networkclient/classes/networkclient/disconnectfromroom/#disconnectfromroom-method","text":"Connects the local player to the room game servers.","title":"DisconnectFromRoom() Method"},{"location":"reference/networkclient/classes/networkclient/disconnectfromroom/#declaration","text":"public void DisconnectFromRoom ();","title":"Declaration"},{"location":"reference/networkclient/classes/networkclient/findspawner/","text":"FindSpawner(ushort) Method Finds the SceneSpawner with the specified SpawnerId. Declaration public SceneSpawner FindSpawner ( ushort spawnerId ); Parameters Type Description spawnerId ushort The spawnerId of the SceneSpawner.","title":"FinsSpawner(ushort)"},{"location":"reference/networkclient/classes/networkclient/findspawner/#findspawnerushort-method","text":"Finds the SceneSpawner with the specified SpawnerId.","title":"FindSpawner(ushort) Method"},{"location":"reference/networkclient/classes/networkclient/findspawner/#declaration","text":"public SceneSpawner FindSpawner ( ushort spawnerId ); Parameters Type Description spawnerId ushort The spawnerId of the SceneSpawner.","title":"Declaration"},{"location":"reference/networkclient/classes/networkclient/summary/","text":"NetworkClient Class Declaration public class NetworkClient : MonoBehaviour Properties Name Type Description VERSION string SWNetwork SDK version. Lobby SWLobby Lobby instance. IsHost bool Indicates whether the local player is the host of a game. IsHost gets set when clients connect to the room game server and is managed by the game server. The game server monitors all connected clients. If the current host player got disconnected, the game server will select a new host. PlayerId string Local player's Id. LastSpawner SceneSpawner Last SceneSpawner. Usually, it is the SceneSpawner of the last loaded scene. loggingLevel LoggingLevel Controls the logging of the SWNetwork SDK lower level code. Error is the default setting. Log File Path string Controls log output directory Development Player Id string Overrides the playerId for development use. On the first launch of a SocketWeaver powered networked game, SWNetwork SDK generates a unique playerId and stores it in the player's device hard drive. The playerId is used in the SocketWeaver backend to identify the player. For development and testing use, you can manually assign a playerId using this field. API_KEY string The APIKEY of your game. It is generated in the SocketWeaver Developer Portal lobbyName string Preferred Lobby region name. nodeRegion1 string Preferred game server region name1. nodeRegion2 string Preferred game server region name2. Methods Name Description ConnectToRoom(Action) Connects the local player to the room game servers. DisconnectFromRoom() Disconnects the local player from the room game servers. CheckIn() Checks into the SocketWeaver services with a random unique player Id. CheckIn(string) Checks into the SocketWeaver services with the specified playerId. Make sure the playerId is unique. FindSpawner(UInt16) Finds the SceneSpawner with the specified SpawnerId.","title":"Summary"},{"location":"reference/networkclient/classes/networkclient/summary/#networkclient-class","text":"","title":"NetworkClient Class"},{"location":"reference/networkclient/classes/networkclient/summary/#declaration","text":"public class NetworkClient : MonoBehaviour","title":"Declaration"},{"location":"reference/networkclient/classes/networkclient/summary/#properties","text":"Name Type Description VERSION string SWNetwork SDK version. Lobby SWLobby Lobby instance. IsHost bool Indicates whether the local player is the host of a game. IsHost gets set when clients connect to the room game server and is managed by the game server. The game server monitors all connected clients. If the current host player got disconnected, the game server will select a new host. PlayerId string Local player's Id. LastSpawner SceneSpawner Last SceneSpawner. Usually, it is the SceneSpawner of the last loaded scene. loggingLevel LoggingLevel Controls the logging of the SWNetwork SDK lower level code. Error is the default setting. Log File Path string Controls log output directory Development Player Id string Overrides the playerId for development use. On the first launch of a SocketWeaver powered networked game, SWNetwork SDK generates a unique playerId and stores it in the player's device hard drive. The playerId is used in the SocketWeaver backend to identify the player. For development and testing use, you can manually assign a playerId using this field. API_KEY string The APIKEY of your game. It is generated in the SocketWeaver Developer Portal lobbyName string Preferred Lobby region name. nodeRegion1 string Preferred game server region name1. nodeRegion2 string Preferred game server region name2.","title":"Properties"},{"location":"reference/networkclient/classes/networkclient/summary/#methods","text":"Name Description ConnectToRoom(Action) Connects the local player to the room game servers. DisconnectFromRoom() Disconnects the local player from the room game servers. CheckIn() Checks into the SocketWeaver services with a random unique player Id. CheckIn(string) Checks into the SocketWeaver services with the specified playerId. Make sure the playerId is unique. FindSpawner(UInt16) Finds the SceneSpawner with the specified SpawnerId.","title":"Methods"},{"location":"sdk/gameplay/networkid/","text":"NetworkID Used to Identify a GameObject in a networked game. Name Function ID Automatically assign at run time. OwnerRemotePlayerId The owner's full playerId. OwnerCustomPlayerId The owner's custom playerId. Type Player : Player controlled GameObject. Non-Player : Non-player controlled GameObject. SendRealtimeData Indicates whether the networked GameObject sends Realtime data to the game server. Only controls the behaviour of non-player networked GameObjects. DynamicallySpawned Disable this for non-player networked GameObjects that are not spawned/destroyed by the SceneSpawner. FixedNetworkObjectID The Fixed NetworkObjectID of the non-player Networked GameObject that are not spawned/destroyed by the SceneSpawner. A valid FixedNetworkObjectIDs should be between 1-4999 . Filterable Indicates whether the GameObject can be filtered by the realtime filter. Only controls the behaviour of player networked GameObjects . Visible Size Size of the bounding box of the GameObject. Creation Player controlled networked GameObjects Created dynamically by the SceneSpawners. Non-player controlled networked GameObjects Created dynamically by the SceneSpawners. Created statically by assigning FixedNetworkObjectIDs. Ownership You can find out if local player is the owner of a networked GameObject by checking the IsMine proprotry of its NetworkID component. Example In this example, NetworkID.IsMine is called to find out if the local player has the authority to move the GameObject. Only the GameObjects that the local player owns should receive input updates. using UnityEngine ; using SWNetwork ; public class PlayerMovement : MonoBehaviour { public float moveSpeed = 6.0F ; CharacterController characterController ; NetworkID networkId ; void Start () { networkId = GetComponent NetworkID (); characterController = GetComponent CharacterController (); } void Update () { if ( networkId . IsMine ) { float speedX = Input . GetAxis ( Horizontal ) * moveSpeed ; float speedZ = Input . GetAxis ( Vertical ) * moveSpeed ; Vector3 movement = new Vector3 ( speedX , verticalVelocity , speedZ ); characterController . Move ( movement * Time . deltaTime ); } } } Destroy You can destroy a networked GameObject by calling the Destroy(float) method of its NetworkID component. The networked GameObject will be removed across the network. The optional parameter specifies the amount of delay in seconds before destroying. Example In this example, NetworkID.Destroy(float) is called to destory the networked GameObject with a delay of 2.5 seconds. void Die () { if ( NetworkClient . Instance == null || NetworkClient . Instance . IsHost ) { networkID . Destroy ( 2.5f ); } } FAQ What would be the best way to restore a player status (position, health, etc.) after he closes the game and comes back a moment later? The SceneSpawner would just spawn a new player GameObject, but I'd like to restore its status to when he disconnected. Answer : If players leave temporarily and reconnect back to the rooms, you probably want to use a longer playerTimeToLive to create rooms. So players don't get removed from rooms too quickly. NetworkObjectID Range Every networked GameObject must have a NetworkID component, and the SDK assigns a unique id to each NetworkID component. The id has a range from 1 to 65535. 1-25000 is reserved for player-owned objects. each player can have up to 100 networked objects so id of 100-199 is owned by player 1 in the game, 200-299 is owned by player 2 in the game... When players connect to the room game server, the game server will assign roomPlayerIDs to them, and roomPlayerID 1 will be assigned to the first player connects to the room. roomPlayerID 2 will be assigned to the second player connects to the room... If the first player went offline and reconnect back to the room game server before the room playerTimeToLive is over, the room game server still remembers the player's roomPlayerID (which is 1 in this case). so the player will gain ownership of the GameObjects with ID in the 100-199 range. If the first player went offline for too long and got kicked by the room keeper, the player's roomPlayerID will be recycled and appended to the end of the available roomPlayerID queue. So if the player joins the same room again, a new roomPlayerID will be assigned. Say the new roomPlayerID is 3, the player will create new sets of GameObjects and own GameObjects with id in the 300-399 range.","title":"NetworkID"},{"location":"sdk/gameplay/networkid/#networkid","text":"Used to Identify a GameObject in a networked game. Name Function ID Automatically assign at run time. OwnerRemotePlayerId The owner's full playerId. OwnerCustomPlayerId The owner's custom playerId. Type Player : Player controlled GameObject. Non-Player : Non-player controlled GameObject. SendRealtimeData Indicates whether the networked GameObject sends Realtime data to the game server. Only controls the behaviour of non-player networked GameObjects. DynamicallySpawned Disable this for non-player networked GameObjects that are not spawned/destroyed by the SceneSpawner. FixedNetworkObjectID The Fixed NetworkObjectID of the non-player Networked GameObject that are not spawned/destroyed by the SceneSpawner. A valid FixedNetworkObjectIDs should be between 1-4999 . Filterable Indicates whether the GameObject can be filtered by the realtime filter. Only controls the behaviour of player networked GameObjects . Visible Size Size of the bounding box of the GameObject.","title":"NetworkID"},{"location":"sdk/gameplay/networkid/#creation","text":"","title":"Creation"},{"location":"sdk/gameplay/networkid/#player-controlled-networked-gameobjects","text":"Created dynamically by the SceneSpawners.","title":"Player controlled networked GameObjects"},{"location":"sdk/gameplay/networkid/#non-player-controlled-networked-gameobjects","text":"Created dynamically by the SceneSpawners. Created statically by assigning FixedNetworkObjectIDs.","title":"Non-player controlled networked GameObjects"},{"location":"sdk/gameplay/networkid/#ownership","text":"You can find out if local player is the owner of a networked GameObject by checking the IsMine proprotry of its NetworkID component.","title":"Ownership"},{"location":"sdk/gameplay/networkid/#example","text":"In this example, NetworkID.IsMine is called to find out if the local player has the authority to move the GameObject. Only the GameObjects that the local player owns should receive input updates. using UnityEngine ; using SWNetwork ; public class PlayerMovement : MonoBehaviour { public float moveSpeed = 6.0F ; CharacterController characterController ; NetworkID networkId ; void Start () { networkId = GetComponent NetworkID (); characterController = GetComponent CharacterController (); } void Update () { if ( networkId . IsMine ) { float speedX = Input . GetAxis ( Horizontal ) * moveSpeed ; float speedZ = Input . GetAxis ( Vertical ) * moveSpeed ; Vector3 movement = new Vector3 ( speedX , verticalVelocity , speedZ ); characterController . Move ( movement * Time . deltaTime ); } } }","title":"Example"},{"location":"sdk/gameplay/networkid/#destroy","text":"You can destroy a networked GameObject by calling the Destroy(float) method of its NetworkID component. The networked GameObject will be removed across the network. The optional parameter specifies the amount of delay in seconds before destroying.","title":"Destroy"},{"location":"sdk/gameplay/networkid/#example_1","text":"In this example, NetworkID.Destroy(float) is called to destory the networked GameObject with a delay of 2.5 seconds. void Die () { if ( NetworkClient . Instance == null || NetworkClient . Instance . IsHost ) { networkID . Destroy ( 2.5f ); } }","title":"Example"},{"location":"sdk/gameplay/networkid/#faq","text":"What would be the best way to restore a player status (position, health, etc.) after he closes the game and comes back a moment later? The SceneSpawner would just spawn a new player GameObject, but I'd like to restore its status to when he disconnected. Answer : If players leave temporarily and reconnect back to the rooms, you probably want to use a longer playerTimeToLive to create rooms. So players don't get removed from rooms too quickly.","title":"FAQ"},{"location":"sdk/gameplay/networkid/#networkobjectid-range","text":"Every networked GameObject must have a NetworkID component, and the SDK assigns a unique id to each NetworkID component. The id has a range from 1 to 65535. 1-25000 is reserved for player-owned objects. each player can have up to 100 networked objects so id of 100-199 is owned by player 1 in the game, 200-299 is owned by player 2 in the game... When players connect to the room game server, the game server will assign roomPlayerIDs to them, and roomPlayerID 1 will be assigned to the first player connects to the room. roomPlayerID 2 will be assigned to the second player connects to the room... If the first player went offline and reconnect back to the room game server before the room playerTimeToLive is over, the room game server still remembers the player's roomPlayerID (which is 1 in this case). so the player will gain ownership of the GameObjects with ID in the 100-199 range. If the first player went offline for too long and got kicked by the room keeper, the player's roomPlayerID will be recycled and appended to the end of the available roomPlayerID queue. So if the player joins the same room again, a new roomPlayerID will be assigned. Say the new roomPlayerID is 3, the player will create new sets of GameObjects and own GameObjects with id in the 300-399 range.","title":"NetworkObjectID Range"},{"location":"sdk/gameplay/overview/","text":"Gameplay Overview Individual Networked GameObject SWNetwork provides three components for synchronizing and updating individual GameObject states. The agent components can be used independently. RealTimeAgent. RemoteEventAgent. SyncPropertyAgent. RealtimeAgent RealTimeAgent is useful for synchronizing GameObject states that are constantly changing. For example, position, rotation, and Animation. RemoteEventAgent When a player casts a spell, all the remote duplicates of the player should cast the same spell. The RemoteEventAgent is designed to handle this use case. SyncPropertyAgent SyncPropertyAgent is often used to synchronize GameObject states that are not modified frequently. For example, a player's costumes, weapon, and HP. Room Level States SWNetwork also provides three components to manage room level states. You must create separate GameObjects for different room agent components. SceneSpawner RoomPropertyAgent RoomRemoteEventAgent SceneSpawner Manages instantiation and destroy of Networked GameObjects. RoomPropertyAgent RoomPropertyAgent is similar to SyncPropertyAgent, the difference is that RoomPropertyAgent updates room level states. RoomRemoteEventAgent RoomRemoteEventAgent is similar to RemoteEventAgent, the difference is that RoomRemoteEventAgent synchronizes room level actions.","title":"Overview"},{"location":"sdk/gameplay/overview/#gameplay-overview","text":"","title":"Gameplay Overview"},{"location":"sdk/gameplay/overview/#individual-networked-gameobject","text":"SWNetwork provides three components for synchronizing and updating individual GameObject states. The agent components can be used independently. RealTimeAgent. RemoteEventAgent. SyncPropertyAgent.","title":"Individual Networked GameObject"},{"location":"sdk/gameplay/overview/#realtimeagent","text":"RealTimeAgent is useful for synchronizing GameObject states that are constantly changing. For example, position, rotation, and Animation.","title":"RealtimeAgent"},{"location":"sdk/gameplay/overview/#remoteeventagent","text":"When a player casts a spell, all the remote duplicates of the player should cast the same spell. The RemoteEventAgent is designed to handle this use case.","title":"RemoteEventAgent"},{"location":"sdk/gameplay/overview/#syncpropertyagent","text":"SyncPropertyAgent is often used to synchronize GameObject states that are not modified frequently. For example, a player's costumes, weapon, and HP.","title":"SyncPropertyAgent"},{"location":"sdk/gameplay/overview/#room-level-states","text":"SWNetwork also provides three components to manage room level states. You must create separate GameObjects for different room agent components. SceneSpawner RoomPropertyAgent RoomRemoteEventAgent","title":"Room Level States"},{"location":"sdk/gameplay/overview/#scenespawner","text":"Manages instantiation and destroy of Networked GameObjects.","title":"SceneSpawner"},{"location":"sdk/gameplay/overview/#roompropertyagent","text":"RoomPropertyAgent is similar to SyncPropertyAgent, the difference is that RoomPropertyAgent updates room level states.","title":"RoomPropertyAgent"},{"location":"sdk/gameplay/overview/#roomremoteeventagent","text":"RoomRemoteEventAgent is similar to RemoteEventAgent, the difference is that RoomRemoteEventAgent synchronizes room level actions.","title":"RoomRemoteEventAgent"},{"location":"sdk/gameplay/realtimeagent/","text":"RealtimeAgent Realtime Agent Sends state changes of local player controlled GameObjects to SocketWeaver Game Servers.The changes are then distributed to the remote duplicates across different Network. Realtime Agent sends GameObject States across the network at a fixed rate. The frequency can be set on the SocketWeaver Developer portal. portal.socketweaver.com Realtime Agent sends GameObject states unreliably. Each state change is useful, however, as the state changes frequently, it is likely to be replaced by a newer value quickly. If you want reliable state synchronization, Sync Property Agent is designed for that use. Compression Realtime Agent automatically compresses the values to minimize bandwidth usage. You should adjust the Min, Max, and Resolution settings to optimize the compression for your game further. Restore By default, RealTime Agent restores GameObjects states when clients reconnect to the game. Transform Synchronizes GameObject Transform. Name Function Enable Controls whether Transform sync is enabled. Interpolate Controls the interpolation of rotation and scale updates. The larger the number the faster the GameObject interpolates to the target rotation and scale. Smooth Level Controls the smoothness of position updates. The larger the number the smoother the GameObject moves to the target position. However, a larger smooth level will affect the GameObjects responsiveness. Snap Distance Controls the maximum displacement allowed to apply smooth algorithm. If the displacement between two position updates is greater than the Snap distance, the smooth algorithm will be skipped, and the GameObject will snap to the new position. External Freeze Controls how long in seconds the position tracking will be disabled on the remote copies when external position changes are detected. Read Function Controls in which function the remote duplicates will read the position updates. Animation Synchronizes GameObject Animation parameters Name Function Enable Controls whether Animation sync is enabled Target Animator The Animator being synchronized. You need to drag the Animator Component of the GameObject into this field. Generic Synchronizes public fields of any components Name Function Enable Controls whether the Generic tracker is enabled Display Name Only used in Unity Editor Target The component to be synchronized","title":"RealtimeAgent"},{"location":"sdk/gameplay/realtimeagent/#realtimeagent","text":"Realtime Agent Sends state changes of local player controlled GameObjects to SocketWeaver Game Servers.The changes are then distributed to the remote duplicates across different Network. Realtime Agent sends GameObject States across the network at a fixed rate. The frequency can be set on the SocketWeaver Developer portal. portal.socketweaver.com Realtime Agent sends GameObject states unreliably. Each state change is useful, however, as the state changes frequently, it is likely to be replaced by a newer value quickly. If you want reliable state synchronization, Sync Property Agent is designed for that use.","title":"RealtimeAgent"},{"location":"sdk/gameplay/realtimeagent/#compression","text":"Realtime Agent automatically compresses the values to minimize bandwidth usage. You should adjust the Min, Max, and Resolution settings to optimize the compression for your game further.","title":"Compression"},{"location":"sdk/gameplay/realtimeagent/#restore","text":"By default, RealTime Agent restores GameObjects states when clients reconnect to the game.","title":"Restore"},{"location":"sdk/gameplay/realtimeagent/#transform","text":"Synchronizes GameObject Transform. Name Function Enable Controls whether Transform sync is enabled. Interpolate Controls the interpolation of rotation and scale updates. The larger the number the faster the GameObject interpolates to the target rotation and scale. Smooth Level Controls the smoothness of position updates. The larger the number the smoother the GameObject moves to the target position. However, a larger smooth level will affect the GameObjects responsiveness. Snap Distance Controls the maximum displacement allowed to apply smooth algorithm. If the displacement between two position updates is greater than the Snap distance, the smooth algorithm will be skipped, and the GameObject will snap to the new position. External Freeze Controls how long in seconds the position tracking will be disabled on the remote copies when external position changes are detected. Read Function Controls in which function the remote duplicates will read the position updates.","title":"Transform"},{"location":"sdk/gameplay/realtimeagent/#animation","text":"Synchronizes GameObject Animation parameters Name Function Enable Controls whether Animation sync is enabled Target Animator The Animator being synchronized. You need to drag the Animator Component of the GameObject into this field.","title":"Animation"},{"location":"sdk/gameplay/realtimeagent/#generic","text":"Synchronizes public fields of any components Name Function Enable Controls whether the Generic tracker is enabled Display Name Only used in Unity Editor Target The component to be synchronized","title":"Generic"},{"location":"sdk/gameplay/remoteevent/","text":"","title":"Remoteevent"},{"location":"sdk/gameplay/roompropertyagent/","text":"","title":"Roompropertyagent"},{"location":"sdk/gameplay/roomremoteeventagent/","text":"","title":"Roomremoteeventagent"},{"location":"sdk/gameplay/scenespawner/","text":"","title":"Scenespawner"},{"location":"sdk/gameplay/syncproperty/","text":"","title":"Syncproperty"},{"location":"sdk/networkclient/checkin/","text":"Check-in SocketWeaver needs to validate a client's API_KEY before the client can use SocketWeaver services. You can use the CheckIn() method of the NetworkClient class to submit Clients API_KEY to SocketWeaver. The CheckIn() method also submits a client's PlayerId to SocketWeaver, and the PlayerId is used in the Lobby servers and the game servers to identify a player. NetworkClient generates a random unique PlayerId on the first launch of a game and stores the PlayerId on the device hard drive. NetworkClient loads the PlayerId from the hard drive in the Awake() method. Using generated PlayerId If you call CheckIn() method without a custom PlayerId, NetworkClient will use the generated random PlayerId to check into the SocketWeaver services. Custom PlayerId You can use custom player Id to override the generated playerId by calling CheckIn(customPlayerId). This is useful if you use service like Google Firebase to manage user profiles. You can use it for development testing as well. Connect to Lobby Servers After validating clients' API_KEY, SocketWeaver routes clients to the lobby cluster that are geographically closest to them. SWNetwork SDK will automatically connect to the assigned lobby clusters. You can add a handler for the NetworkClient.Lobby.OnLobbyConncetedEvent and start the matchmaking process of your game from there. Methods CheckIn() Checking into the SocketWeaver services with the generated unique player Id. CheckIn(string) Checking into the SocketWeaver services with the specified playerId. Make sure the playerId is unique. Example string customPlayerId = a1b2c3d4 ; NetworkClient . Instance . CheckIn ( customPlayerId , ( bool successful , string error ) = { if (! successful ) { Debug . LogError ( error ); } });","title":"Check-in"},{"location":"sdk/networkclient/checkin/#check-in","text":"SocketWeaver needs to validate a client's API_KEY before the client can use SocketWeaver services. You can use the CheckIn() method of the NetworkClient class to submit Clients API_KEY to SocketWeaver. The CheckIn() method also submits a client's PlayerId to SocketWeaver, and the PlayerId is used in the Lobby servers and the game servers to identify a player. NetworkClient generates a random unique PlayerId on the first launch of a game and stores the PlayerId on the device hard drive. NetworkClient loads the PlayerId from the hard drive in the Awake() method.","title":"Check-in"},{"location":"sdk/networkclient/checkin/#using-generated-playerid","text":"If you call CheckIn() method without a custom PlayerId, NetworkClient will use the generated random PlayerId to check into the SocketWeaver services.","title":"Using generated PlayerId"},{"location":"sdk/networkclient/checkin/#custom-playerid","text":"You can use custom player Id to override the generated playerId by calling CheckIn(customPlayerId). This is useful if you use service like Google Firebase to manage user profiles. You can use it for development testing as well.","title":"Custom PlayerId"},{"location":"sdk/networkclient/checkin/#connect-to-lobby-servers","text":"After validating clients' API_KEY, SocketWeaver routes clients to the lobby cluster that are geographically closest to them. SWNetwork SDK will automatically connect to the assigned lobby clusters. You can add a handler for the NetworkClient.Lobby.OnLobbyConncetedEvent and start the matchmaking process of your game from there. Methods CheckIn() Checking into the SocketWeaver services with the generated unique player Id. CheckIn(string) Checking into the SocketWeaver services with the specified playerId. Make sure the playerId is unique.","title":"Connect to Lobby Servers"},{"location":"sdk/networkclient/checkin/#example","text":"string customPlayerId = a1b2c3d4 ; NetworkClient . Instance . CheckIn ( customPlayerId , ( bool successful , string error ) = { if (! successful ) { Debug . LogError ( error ); } });","title":"Example"},{"location":"sdk/networkclient/configuration/","text":"Configuration NetworkClient can be configured using the NetworkClient custom inspector. It is recommended to add the NetworkClient component to a separate GameObject in your scene. NetworkClient will automatically prevent the GameObject from being destroyed between Scenes. Properties Name Function Logging Level Controls the logging of the SWNetwork SDK lower level code. Error is the default setting. Log File Path Controls log output directory. API_KEY The APIKEY of your game. It is generated in the SocketWeaver Developer Portal. Routing info SocketWeaver routes traffic based on the location of players. The section below the API_KEY text field shows the routing information of a client. The first line \"f6921e3a...\" is the playerId.","title":"Configuration"},{"location":"sdk/networkclient/configuration/#configuration","text":"NetworkClient can be configured using the NetworkClient custom inspector. It is recommended to add the NetworkClient component to a separate GameObject in your scene. NetworkClient will automatically prevent the GameObject from being destroyed between Scenes.","title":"Configuration"},{"location":"sdk/networkclient/configuration/#properties","text":"Name Function Logging Level Controls the logging of the SWNetwork SDK lower level code. Error is the default setting. Log File Path Controls log output directory. API_KEY The APIKEY of your game. It is generated in the SocketWeaver Developer Portal.","title":"Properties"},{"location":"sdk/networkclient/configuration/#routing-info","text":"SocketWeaver routes traffic based on the location of players. The section below the API_KEY text field shows the routing information of a client. The first line \"f6921e3a...\" is the playerId.","title":"Routing info"},{"location":"sdk/networkclient/gameservers/","text":"Game Servers When players in a room are ready to play together, the room owner needs to call NetworkClient.Lobby.StartRoom(). SocketWeaver will start searching for a suitable game server for the room, and the NetworkClient.Lobby.OnRoomReadyEvent will be invoked when the room game server is ready. You need to use the NetworClient.ConnectToRoom(Action) method to connect to the room game server to use the SocketWeaver GamePlay API. When the game is finised, you need to use the NetworkClient.DisconnectFromRoom() method to disconnect from the game servers to stop receiving the game state updates. Methods ConnectToRoom(Action ) Connects the local player to the room game servers. DisconnectFromRoom() Disconnects the local player from the room game servers. Example // Connect to the game servers of the room. void ConnectToRoom () { NetworkClient . Instance . ConnectToRoom ( HandleConnectedToRoom ); } // Callback method NetworkClient.Instance.ConnectToRoom(); // If connected is true,the client has connected to the game servers successfully. /param void HandleConnectedToRoom ( bool connected ) { if ( connected ) { Debug . Log ( Connected to room ); // load the game scene SceneManager . LoadScene ( 1 ); } else { Debug . Log ( Failed to connect to room ); } }","title":"Game Servers"},{"location":"sdk/networkclient/gameservers/#game-servers","text":"When players in a room are ready to play together, the room owner needs to call NetworkClient.Lobby.StartRoom(). SocketWeaver will start searching for a suitable game server for the room, and the NetworkClient.Lobby.OnRoomReadyEvent will be invoked when the room game server is ready. You need to use the NetworClient.ConnectToRoom(Action) method to connect to the room game server to use the SocketWeaver GamePlay API. When the game is finised, you need to use the NetworkClient.DisconnectFromRoom() method to disconnect from the game servers to stop receiving the game state updates. Methods ConnectToRoom(Action ) Connects the local player to the room game servers. DisconnectFromRoom() Disconnects the local player from the room game servers.","title":"Game Servers"},{"location":"sdk/networkclient/gameservers/#example","text":"// Connect to the game servers of the room. void ConnectToRoom () { NetworkClient . Instance . ConnectToRoom ( HandleConnectedToRoom ); } // Callback method NetworkClient.Instance.ConnectToRoom(); // If connected is true,the client has connected to the game servers successfully. /param void HandleConnectedToRoom ( bool connected ) { if ( connected ) { Debug . Log ( Connected to room ); // load the game scene SceneManager . LoadScene ( 1 ); } else { Debug . Log ( Failed to connect to room ); } }","title":"Example"},{"location":"sdk/networkclient/networkstatusevent/","text":"Network Status Events The NetworkClient invokes the following event to help you detect connectivity issues. Methods ConnectToRoom(Action ) Connects the local player to the room game servers. DisconnectFromRoom() Disconnects the local player from the room game servers. Example // Connect to the game servers of the room. void ConnectToRoom () { NetworkClient . Instance . ConnectToRoom ( HandleConnectedToRoom ); } // Callback method NetworkClient.Instance.ConnectToRoom(); // If connected is true,the client has connected to the game servers successfully. /param void HandleConnectedToRoom ( bool connected ) { if ( connected ) { Debug . Log ( Connected to room ); // load the game scene SceneManager . LoadScene ( 1 ); } else { Debug . Log ( Failed to connect to room ); } }","title":"Network Status Events"},{"location":"sdk/networkclient/networkstatusevent/#network-status-events","text":"The NetworkClient invokes the following event to help you detect connectivity issues. Methods ConnectToRoom(Action ) Connects the local player to the room game servers. DisconnectFromRoom() Disconnects the local player from the room game servers.","title":"Network Status Events"},{"location":"sdk/networkclient/networkstatusevent/#example","text":"// Connect to the game servers of the room. void ConnectToRoom () { NetworkClient . Instance . ConnectToRoom ( HandleConnectedToRoom ); } // Callback method NetworkClient.Instance.ConnectToRoom(); // If connected is true,the client has connected to the game servers successfully. /param void HandleConnectedToRoom ( bool connected ) { if ( connected ) { Debug . Log ( Connected to room ); // load the game scene SceneManager . LoadScene ( 1 ); } else { Debug . Log ( Failed to connect to room ); } }","title":"Example"},{"location":"sdk/networkclient/overview/","text":"NetworkClient Overview NetworkClient is the entry point of your game to interact with the SocketWeaver backend services. You must have one and only one NetworkClient active in your Scene. The NetworkClient's main responsibilites include the following: Checking into the SocketWeaver services. Managing the connections to the lobby server and the room game servers. Lifecycle NetworkClient automatically calls its own methods in different MonoBahaviour event functions.","title":"Overview"},{"location":"sdk/networkclient/overview/#networkclient-overview","text":"NetworkClient is the entry point of your game to interact with the SocketWeaver backend services. You must have one and only one NetworkClient active in your Scene. The NetworkClient's main responsibilites include the following: Checking into the SocketWeaver services. Managing the connections to the lobby server and the room game servers.","title":"NetworkClient Overview"},{"location":"sdk/networkclient/overview/#lifecycle","text":"NetworkClient automatically calls its own methods in different MonoBahaviour event functions.","title":"Lifecycle"},{"location":"tutorials/top-down/installation/","text":"Install the SWNetwork SDK Please follow the steps in the Installation page to install the SWNetwork SDK.","title":"Installation"},{"location":"tutorials/top-down/installation/#install-the-swnetwork-sdk","text":"Please follow the steps in the Installation page to install the SWNetwork SDK.","title":"Install the SWNetwork SDK"},{"location":"tutorials/top-down/introduction/","text":"Top-Down Shooter Requirements Unity 2018.3.4 or later . You can download the latest version of Unity here: https://unity3d.com/get-unity/download A SocketWeaver Account . You can create a SocketWeaver Account for free here: https://portal.socketweaver.com All accounts get 20GB of data for free every month. What we are making In this tutorial, we are going to make a multiplayer top-down shooter. We will show you the process step-by-step. By the time you finished reading this tutorial, you will be ready to start converting your own game or explore more advanced features that our Unity SDK provides. Source Code The source code of this tutorial is hosted at: https://github.com/SocketWeaver/third-person The repository has two Unity Projects: Starter The starter project of the tutorial. It has all the assets you need to complete the tutorial. The Starter Project has one scene: Game scene. Game scene You can use the WASD keys or the Arrow keys to move the cube around. Pressing the Space key makes the cube jump. Mouse movement controls the cube's direction. Mouse Left Click fires bullets. Final The final playable multiplayer game. Community If you have questions about the tutorial, join our Discord server: https://discord.gg/qXt7Bkf","title":"Introduction"},{"location":"tutorials/top-down/introduction/#top-down-shooter","text":"","title":"Top-Down Shooter"},{"location":"tutorials/top-down/introduction/#requirements","text":"Unity 2018.3.4 or later . You can download the latest version of Unity here: https://unity3d.com/get-unity/download A SocketWeaver Account . You can create a SocketWeaver Account for free here: https://portal.socketweaver.com All accounts get 20GB of data for free every month.","title":"Requirements"},{"location":"tutorials/top-down/introduction/#what-we-are-making","text":"In this tutorial, we are going to make a multiplayer top-down shooter. We will show you the process step-by-step. By the time you finished reading this tutorial, you will be ready to start converting your own game or explore more advanced features that our Unity SDK provides.","title":"What we are making"},{"location":"tutorials/top-down/introduction/#source-code","text":"The source code of this tutorial is hosted at: https://github.com/SocketWeaver/third-person","title":"Source Code"},{"location":"tutorials/top-down/introduction/#the-repository-has-two-unity-projects","text":"","title":"The repository has two Unity Projects:"},{"location":"tutorials/top-down/introduction/#starter","text":"The starter project of the tutorial. It has all the assets you need to complete the tutorial. The Starter Project has one scene: Game scene.","title":"Starter"},{"location":"tutorials/top-down/introduction/#game-scene","text":"You can use the WASD keys or the Arrow keys to move the cube around. Pressing the Space key makes the cube jump. Mouse movement controls the cube's direction. Mouse Left Click fires bullets.","title":"Game scene"},{"location":"tutorials/top-down/introduction/#final","text":"The final playable multiplayer game.","title":"Final"},{"location":"tutorials/top-down/introduction/#community","text":"If you have questions about the tutorial, join our Discord server: https://discord.gg/qXt7Bkf","title":"Community"},{"location":"tutorials/top-down/player-respawn/","text":"Player Respawn 3 - 5 minutes read As the players shoot each other, their hp reaches 0 and stays at 0. You can add another remote event to trigger the player explosion death effect. Player Explosion Add another remote event and name it \"killed\". In the PlayerHP.cs Script: Add a RemoteEventAgent property and initialize it in the Start() method. RemoteEventAgent remoteEventAgent ; void Start () { hpSlider . minValue = 0 ; hpSlider . maxValue = maxHp ; \u200b networkId = GetComponent NetworkID (); syncPropertyAgent = gameObject . GetComponent SyncPropertyAgent (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } Update the OnHpChanged() method to invoke the \"killed\" remote event when hp is 0. public void OnHpChanged () { // Update the hpSlider when player hp changes currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); hpSlider . value = currentHP ; \u200b if ( currentHP == 0 ) { // invoke the killed remote event when hp is 0. if ( networkId . IsMine ) { remoteEventAgent . Invoke ( killed ); } } } Add RemoteKilled() method to handle the \"killed\" remote event. public void RemoteKilled () { Instantiate ( explode , transform . position , Quaternion . identity ); } Hook up the event listener in the Editor Inspector. Tip Make sure you applied the changes to the Player Prefab Respawning the Player In the GameSceneManager.cs script, add the following methods to respawn the player. public void DelayedRespawnPlayer () { // Respawn the player in 1 second StartCoroutine ( RespawnPlayer ( 1f )); } IEnumerator RespawnPlayer ( float delayTime ) { yield return new WaitForSeconds ( delayTime ); // Respawn the player at a random SpawnPoint int spawnPointIndex = Random . Range ( 0 , 3 ); NetworkClient . Instance . LastSpawner . SpawnForPlayer ( 0 , spawnPointIndex ); } In the PlayerHP.cs script, update the RemoteKilled() method. public void RemoteKilled () { Instantiate ( explode , transform . position , Quaternion . identity ); \u200b // Only the source player GameObject should be respawned. // SceneSpawner will handle the remote duplicate creation for the respawned player. if ( networkId . IsMine ) { GameSceneManager gameSceneManager = FindObjectOfType GameSceneManager (); \u200b // Call the DelayedRespawnPlayer() method you just added to the GameSceneManager.cs script. gameSceneManager . DelayedRespawnPlayer (); \u200b // Ask the SceneSpawner to destroy the gameObject. // SceneSpawner will destroy the local Player and its remote duplicates. NetworkClient . Instance . LastSpawner . DestroyGameObject ( gameObject ); } } Play You can follow the steps in section Test and Play to test out the changes made in this page.","title":"Player Respawn"},{"location":"tutorials/top-down/player-respawn/#player-respawn","text":"3 - 5 minutes read As the players shoot each other, their hp reaches 0 and stays at 0. You can add another remote event to trigger the player explosion death effect.","title":"Player Respawn"},{"location":"tutorials/top-down/player-respawn/#player-explosion","text":"Add another remote event and name it \"killed\". In the PlayerHP.cs Script: Add a RemoteEventAgent property and initialize it in the Start() method. RemoteEventAgent remoteEventAgent ; void Start () { hpSlider . minValue = 0 ; hpSlider . maxValue = maxHp ; \u200b networkId = GetComponent NetworkID (); syncPropertyAgent = gameObject . GetComponent SyncPropertyAgent (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } Update the OnHpChanged() method to invoke the \"killed\" remote event when hp is 0. public void OnHpChanged () { // Update the hpSlider when player hp changes currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); hpSlider . value = currentHP ; \u200b if ( currentHP == 0 ) { // invoke the killed remote event when hp is 0. if ( networkId . IsMine ) { remoteEventAgent . Invoke ( killed ); } } } Add RemoteKilled() method to handle the \"killed\" remote event. public void RemoteKilled () { Instantiate ( explode , transform . position , Quaternion . identity ); } Hook up the event listener in the Editor Inspector. Tip Make sure you applied the changes to the Player Prefab","title":"Player Explosion"},{"location":"tutorials/top-down/player-respawn/#respawning-the-player","text":"In the GameSceneManager.cs script, add the following methods to respawn the player. public void DelayedRespawnPlayer () { // Respawn the player in 1 second StartCoroutine ( RespawnPlayer ( 1f )); } IEnumerator RespawnPlayer ( float delayTime ) { yield return new WaitForSeconds ( delayTime ); // Respawn the player at a random SpawnPoint int spawnPointIndex = Random . Range ( 0 , 3 ); NetworkClient . Instance . LastSpawner . SpawnForPlayer ( 0 , spawnPointIndex ); } In the PlayerHP.cs script, update the RemoteKilled() method. public void RemoteKilled () { Instantiate ( explode , transform . position , Quaternion . identity ); \u200b // Only the source player GameObject should be respawned. // SceneSpawner will handle the remote duplicate creation for the respawned player. if ( networkId . IsMine ) { GameSceneManager gameSceneManager = FindObjectOfType GameSceneManager (); \u200b // Call the DelayedRespawnPlayer() method you just added to the GameSceneManager.cs script. gameSceneManager . DelayedRespawnPlayer (); \u200b // Ask the SceneSpawner to destroy the gameObject. // SceneSpawner will destroy the local Player and its remote duplicates. NetworkClient . Instance . LastSpawner . DestroyGameObject ( gameObject ); } }","title":"Respawning the Player"},{"location":"tutorials/top-down/player-respawn/#play","text":"You can follow the steps in section Test and Play to test out the changes made in this page.","title":"Play"},{"location":"tutorials/top-down/remote-events/","text":"Remote Events 5 - 10 minutes read It's time for some shooting! You might have noticed that the shooting action is not synced. In this section, you will add a remote event to the Player Prefab to sync player actions. RemoteEventAgent Select the Player Prefab. Click the Add Component button and Search \"Agent\", select Remote Event Agent to attach it to the Player GameObject. Click on the Add Remote Event button and set the event name to \"fire\". The event name is used to find and trigger a remote event across different networks. Warning Make sure that remote events in the same RemoteEventAgent have different event names. The SocketWeaver remote events are super charged Unity events. You can invoke them in scripts. You can add listeners to handle them, and when a remote events is invoked, the listeners of the same remote event in different network will be triggered. You need to update the PlayerWeapon.cs script to invoke and handle the \"fire\" event. Add two properties: networkId, and remoteEventAgent. NetworkID networkId ; RemoteEventAgent remoteEventAgent ; Implement the Start() method and initialize the networkId, and remoteEventAgent properties. void Start () { networkId = GetComponent NetworkID (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } Only the source GameObject should receive user inputs, we can use the IsMine property of NetworkID component to find out if the Player GameObject is the source GameObject. void Update () { if ( networkId . IsMine ) { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } } Update the fireBullet() method to invoke the \"fire\" event. We used SWNetworkMessage to send the bullet launch position(vector3) and aim direction (vector3) along with the \"fire\" event. void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); remoteEventAgent . Invoke ( fire , msg ); } Implement the Event Handler method. We used PopVector3() method on the SWNetworkMessage object to obtain the launch position and aim direction of the fire remote event. public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); gun . fireBullet ( position , direction ); } The final version of PlayerWeapon.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b public class PlayerWeapon : MonoBehaviour { // aimable layers public LayerMask layerMask ; \u200b private Vector3 currentLookTarget = Vector3 . zero ; public Gun gun ; \u200b // launch position of bullets public Transform launchPosition ; \u200b NetworkID networkId ; RemoteEventAgent remoteEventAgent ; \u200b private void Start () { networkId = GetComponent NetworkID (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } \u200b void FixedUpdate () { if ( networkId . IsMine ) { // find player s cursor position in the environment RaycastHit hit ; Ray ray = Camera . main . ScreenPointToRay ( Input . mousePosition ); Debug . DrawRay ( ray . origin , ray . direction * 1000 , Color . green ); if ( Physics . Raycast ( ray , out hit , 1000 , layerMask , QueryTriggerInteraction . Ignore )) { if ( hit . point != currentLookTarget ) { currentLookTarget = hit . point ; } } \u200b // ignore cursor position s y value. Vector3 targetPosition = new Vector3 ( hit . point . x , transform . position . y , hit . point . z ); \u200b // calculate player s new rotation Quaternion rotation = Quaternion . LookRotation ( targetPosition - transform . position ); \u200b // lerp transform . rotation = Quaternion . Lerp ( transform . rotation , rotation , Time . deltaTime * 10.0f ); } } \u200b void Update () { if ( networkId . IsMine ) { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } } \u200b void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); remoteEventAgent . Invoke ( fire , msg ); } \u200b public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); gun . FireBullet ( position , direction ); } } Add a listener to the \"fire\" event. Make sure to select the RemoteFire() method under the Dynamic Parameter Section of the methods list. Tip Make sure you applied the changes to the Player Prefab. Double check if the player prefab has been saved correctly by inspecting the Player prefab in the /Assets/prefabs folder. Make sure the RemoteEventAgent is saved and the prefab is enabled. Play Tip Make sure you disabled the Player GameObject in the Hierarchy. You can follow the steps in the last section Test and Play to test out the \"fire\" remote event.","title":"Remote Events"},{"location":"tutorials/top-down/remote-events/#remote-events","text":"5 - 10 minutes read It's time for some shooting! You might have noticed that the shooting action is not synced. In this section, you will add a remote event to the Player Prefab to sync player actions.","title":"Remote Events"},{"location":"tutorials/top-down/remote-events/#remoteeventagent","text":"Select the Player Prefab. Click the Add Component button and Search \"Agent\", select Remote Event Agent to attach it to the Player GameObject. Click on the Add Remote Event button and set the event name to \"fire\". The event name is used to find and trigger a remote event across different networks. Warning Make sure that remote events in the same RemoteEventAgent have different event names. The SocketWeaver remote events are super charged Unity events. You can invoke them in scripts. You can add listeners to handle them, and when a remote events is invoked, the listeners of the same remote event in different network will be triggered. You need to update the PlayerWeapon.cs script to invoke and handle the \"fire\" event. Add two properties: networkId, and remoteEventAgent. NetworkID networkId ; RemoteEventAgent remoteEventAgent ; Implement the Start() method and initialize the networkId, and remoteEventAgent properties. void Start () { networkId = GetComponent NetworkID (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } Only the source GameObject should receive user inputs, we can use the IsMine property of NetworkID component to find out if the Player GameObject is the source GameObject. void Update () { if ( networkId . IsMine ) { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } } Update the fireBullet() method to invoke the \"fire\" event. We used SWNetworkMessage to send the bullet launch position(vector3) and aim direction (vector3) along with the \"fire\" event. void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); remoteEventAgent . Invoke ( fire , msg ); } Implement the Event Handler method. We used PopVector3() method on the SWNetworkMessage object to obtain the launch position and aim direction of the fire remote event. public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); gun . fireBullet ( position , direction ); } The final version of PlayerWeapon.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b public class PlayerWeapon : MonoBehaviour { // aimable layers public LayerMask layerMask ; \u200b private Vector3 currentLookTarget = Vector3 . zero ; public Gun gun ; \u200b // launch position of bullets public Transform launchPosition ; \u200b NetworkID networkId ; RemoteEventAgent remoteEventAgent ; \u200b private void Start () { networkId = GetComponent NetworkID (); remoteEventAgent = gameObject . GetComponent RemoteEventAgent (); } \u200b void FixedUpdate () { if ( networkId . IsMine ) { // find player s cursor position in the environment RaycastHit hit ; Ray ray = Camera . main . ScreenPointToRay ( Input . mousePosition ); Debug . DrawRay ( ray . origin , ray . direction * 1000 , Color . green ); if ( Physics . Raycast ( ray , out hit , 1000 , layerMask , QueryTriggerInteraction . Ignore )) { if ( hit . point != currentLookTarget ) { currentLookTarget = hit . point ; } } \u200b // ignore cursor position s y value. Vector3 targetPosition = new Vector3 ( hit . point . x , transform . position . y , hit . point . z ); \u200b // calculate player s new rotation Quaternion rotation = Quaternion . LookRotation ( targetPosition - transform . position ); \u200b // lerp transform . rotation = Quaternion . Lerp ( transform . rotation , rotation , Time . deltaTime * 10.0f ); } } \u200b void Update () { if ( networkId . IsMine ) { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } } \u200b void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); remoteEventAgent . Invoke ( fire , msg ); } \u200b public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); gun . FireBullet ( position , direction ); } } Add a listener to the \"fire\" event. Make sure to select the RemoteFire() method under the Dynamic Parameter Section of the methods list. Tip Make sure you applied the changes to the Player Prefab. Double check if the player prefab has been saved correctly by inspecting the Player prefab in the /Assets/prefabs folder. Make sure the RemoteEventAgent is saved and the prefab is enabled.","title":"RemoteEventAgent"},{"location":"tutorials/top-down/remote-events/#play","text":"Tip Make sure you disabled the Player GameObject in the Hierarchy. You can follow the steps in the last section Test and Play to test out the \"fire\" remote event.","title":"Play"},{"location":"tutorials/top-down/set-up-the-networkclient/","text":"Setting up the NetworkClient 1 - 3 minutes read LobbyScene For simplicity, you are going to use the example LobbyScene included in the SWNetwork package for this tutorial. The LobbyScene is located at Assets/SWNetwork/Scenes/LobbyScene . The LobbyScene uses the JoinOrCreate() method to get players into rooms quickly. SWNetwork has a rich set of APIs to use for matchmaking. If you want to extend the matchmaking logic of your game further, please visit the Lobby API documentation . Set up the NetworkClient NetworkClient is the entry point of your game to interact with the SocketWeaver backend services. You must have one and only one NetworkClient active in your Scene. In the LobbyScene hierarchy, select the NetworkClient GameObject. You will notice that a NetworkClient component is attached to it. NetworkClient has a few properties you can change. For now, you just need to configure its API_KEY property to get your game running. Go to SocketWeaver Developer Portal , and create a new game. Click the Copy button to copy the API key to your clipboard, paste it into the API_KEY textfield of the NetworkClient Component. To test if everything is working correctly, you can play the LobbyScene. The game view should look like the screenshot below. If you leave the custom playerId input field empty, LobbyScene will use a randomly generated unique playerId to check into the SocketWeaver services. The generated playerId will be stored in your computer's hard drive, so if you stop playing and play again, the same playerId will be used. The playerId is used to identify a client in the lobby servers and game servers. By clicking the Register button, the LobbyScene sends a request to SocketWeaver, SocketWeaver will validate the API_KEY and route players to a lobby cluster that is geographically closest to them. Once a player is connected to the assigned lobby cluster, the LobbyScene will automatically register the player to the lobby cluster. The Play button should replace the Register button now. By clicking the Play button, the LobbyScene will try to find a room for the player or create a new room if it cannot find a room in the lobby cluster. By default, when a player is connected to the room's game server, the LobbyScene will load the scene at index 1. You can update it to load the Game scene. void HandleConnectedToRoom ( bool connected ) { if ( connected ) { Debug . Log ( Connected to room ); SceneManager . LoadScene ( game ); } else { Debug . Log ( Failed to connect to room ); } }","title":"Setting up the NetworkClient"},{"location":"tutorials/top-down/set-up-the-networkclient/#setting-up-the-networkclient","text":"1 - 3 minutes read","title":"Setting up the NetworkClient"},{"location":"tutorials/top-down/set-up-the-networkclient/#lobbyscene","text":"For simplicity, you are going to use the example LobbyScene included in the SWNetwork package for this tutorial. The LobbyScene is located at Assets/SWNetwork/Scenes/LobbyScene . The LobbyScene uses the JoinOrCreate() method to get players into rooms quickly. SWNetwork has a rich set of APIs to use for matchmaking. If you want to extend the matchmaking logic of your game further, please visit the Lobby API documentation .","title":"LobbyScene"},{"location":"tutorials/top-down/set-up-the-networkclient/#set-up-the-networkclient","text":"NetworkClient is the entry point of your game to interact with the SocketWeaver backend services. You must have one and only one NetworkClient active in your Scene. In the LobbyScene hierarchy, select the NetworkClient GameObject. You will notice that a NetworkClient component is attached to it. NetworkClient has a few properties you can change. For now, you just need to configure its API_KEY property to get your game running. Go to SocketWeaver Developer Portal , and create a new game. Click the Copy button to copy the API key to your clipboard, paste it into the API_KEY textfield of the NetworkClient Component. To test if everything is working correctly, you can play the LobbyScene. The game view should look like the screenshot below. If you leave the custom playerId input field empty, LobbyScene will use a randomly generated unique playerId to check into the SocketWeaver services. The generated playerId will be stored in your computer's hard drive, so if you stop playing and play again, the same playerId will be used. The playerId is used to identify a client in the lobby servers and game servers. By clicking the Register button, the LobbyScene sends a request to SocketWeaver, SocketWeaver will validate the API_KEY and route players to a lobby cluster that is geographically closest to them. Once a player is connected to the assigned lobby cluster, the LobbyScene will automatically register the player to the lobby cluster. The Play button should replace the Register button now. By clicking the Play button, the LobbyScene will try to find a room for the player or create a new room if it cannot find a room in the lobby cluster. By default, when a player is connected to the room's game server, the LobbyScene will load the scene at index 1. You can update it to load the Game scene. void HandleConnectedToRoom ( bool connected ) { if ( connected ) { Debug . Log ( Connected to room ); SceneManager . LoadScene ( game ); } else { Debug . Log ( Failed to connect to room ); } }","title":"Set up the NetworkClient"},{"location":"tutorials/top-down/set-up-the-scenespawner/","text":"Setting up the Scene Spawner 5 - 10 minutes read Player Prefab At this point, you have the Player RealTimeAgent set up. Select the Player GameObject in the Scene Hierarchy and drag it into the Prefabs folder in the Project Assets folder. SceneSpawner Add a new Empty GameObject and name it SceneSpawner . Click the Add Component button and Search \"Spawner\", select SceneSpawner to attach it to the new GameObject. Note that a NetworkSystemID component was attached to SceneSpawner GameObject automatically. NetworkSystemID component help SWNetwork to identify SWNetwork's internal GameObjects. Choose a unique Spawner Id The SceneSpawner instantiates and destroys Networked GameObjects in a Scene(GameObjects that have a NetworkID component). Make sure you give different SpawnerId to different **SceneSpawner**s. Our game only has one SceneSpawner , we can set its SpawnerId to 1. Creating Spawn Points Create an Empty GameObject and name it SpawnPoints , reset its position to (0, 0, 0). Create an Empty GameObject and name it SpawnPoint , and reset its position to (0, 0, 0)as well. Select an Icon for the SpawnPoint so we can easily find it in the Scene. Select the SpawnPoint GameObject in the Hierarchy and drag it into the Prefabs Folder to create a SpawnPoint Prefab. Drag the SpawnPoint prefab into the SpawnPoints GameObject and create 4 SpawnPoints . Move the **SpawnPoint**s to the places you like to spawn the players. Set the Position Y to 1.5 to make sure the players are spawned above the ground. Select the SceneSpawner GameObject, open the Spawn Point section and set the Size to 4. Drag the SpawnPoint into the slots. Adding the Player Prefab to the Scene Spawner Open the Player Prefabs section of the SceneSpawner, drag the Player Prefab into it. Handling the SceneSpawner OnReady Event Open the GameSceneManager.cs script, and add a method to handle the OnReadyEvent of the SceneSpawner. Your GameSceneManager.cs script should look like: using UnityEngine.SceneManagement ; using UnityEngine ; using SWNetwork ; \u200b /// summary /// Game scene manager manages game scenes state. /// /summary public class GameSceneManager : MonoBehaviour { public GameObject winnerPanel ; public GameObject gameOverPanel ; \u200b public void Exit () { // TODO // exit the game } \u200b // OnSpawnerReady(bool alreadySetup) method is added to handle the On Ready Event. public void OnSpawnerReady ( bool alreadySetup ) { Debug . Log ( OnSpawnerReady + alreadySetup ); \u200b // Check alreadySetup to see if the scene has been set up before. // If it is true, it means the player disconnected and reconnected to the game. // In this case, we should not spawn a new Player GameObject for the player. if (! alreadySetup ) { // If alreadySetup is false, it means the player just started the game. // We randomly select a SpawnPoint and ask the SceneSpawner to spawn a Player GameObject. // we have 1 playerPrefabs so playerPrefabIndex is 0. // We have 4 spawnPoints so we generated a random int between 0 to 3. int spawnPointIndex = Random . Range ( 0 , 3 ); NetworkClient . Instance . LastSpawner . SpawnForPlayer ( 0 , spawnPointIndex ); \u200b // Tell the spawner that we have finished setting up the scene. // alreadySetup will be true when SceneSpawn becomes ready next time. NetworkClient . Instance . LastSpawner . PlayerFinishedSceneSetup (); } } } In the SceneSpawner component, add a listener to the On Ready event. Select OnSpawnerReady(bool) in the GameSceneManager.cs script. Make sure to select the OnSpawnerReady method from the Dynamic bool section in the list..","title":"Setting up the SceneSpawner"},{"location":"tutorials/top-down/set-up-the-scenespawner/#setting-up-the-scene-spawner","text":"5 - 10 minutes read","title":"Setting up the Scene Spawner"},{"location":"tutorials/top-down/set-up-the-scenespawner/#player-prefab","text":"At this point, you have the Player RealTimeAgent set up. Select the Player GameObject in the Scene Hierarchy and drag it into the Prefabs folder in the Project Assets folder.","title":"Player Prefab"},{"location":"tutorials/top-down/set-up-the-scenespawner/#scenespawner","text":"Add a new Empty GameObject and name it SceneSpawner . Click the Add Component button and Search \"Spawner\", select SceneSpawner to attach it to the new GameObject. Note that a NetworkSystemID component was attached to SceneSpawner GameObject automatically. NetworkSystemID component help SWNetwork to identify SWNetwork's internal GameObjects.","title":"SceneSpawner"},{"location":"tutorials/top-down/set-up-the-scenespawner/#choose-a-unique-spawner-id","text":"The SceneSpawner instantiates and destroys Networked GameObjects in a Scene(GameObjects that have a NetworkID component). Make sure you give different SpawnerId to different **SceneSpawner**s. Our game only has one SceneSpawner , we can set its SpawnerId to 1.","title":"Choose a unique Spawner Id"},{"location":"tutorials/top-down/set-up-the-scenespawner/#creating-spawn-points","text":"Create an Empty GameObject and name it SpawnPoints , reset its position to (0, 0, 0). Create an Empty GameObject and name it SpawnPoint , and reset its position to (0, 0, 0)as well. Select an Icon for the SpawnPoint so we can easily find it in the Scene. Select the SpawnPoint GameObject in the Hierarchy and drag it into the Prefabs Folder to create a SpawnPoint Prefab. Drag the SpawnPoint prefab into the SpawnPoints GameObject and create 4 SpawnPoints . Move the **SpawnPoint**s to the places you like to spawn the players. Set the Position Y to 1.5 to make sure the players are spawned above the ground. Select the SceneSpawner GameObject, open the Spawn Point section and set the Size to 4. Drag the SpawnPoint into the slots. Adding the Player Prefab to the Scene Spawner Open the Player Prefabs section of the SceneSpawner, drag the Player Prefab into it.","title":"Creating Spawn Points"},{"location":"tutorials/top-down/set-up-the-scenespawner/#handling-the-scenespawner-onready-event","text":"Open the GameSceneManager.cs script, and add a method to handle the OnReadyEvent of the SceneSpawner. Your GameSceneManager.cs script should look like: using UnityEngine.SceneManagement ; using UnityEngine ; using SWNetwork ; \u200b /// summary /// Game scene manager manages game scenes state. /// /summary public class GameSceneManager : MonoBehaviour { public GameObject winnerPanel ; public GameObject gameOverPanel ; \u200b public void Exit () { // TODO // exit the game } \u200b // OnSpawnerReady(bool alreadySetup) method is added to handle the On Ready Event. public void OnSpawnerReady ( bool alreadySetup ) { Debug . Log ( OnSpawnerReady + alreadySetup ); \u200b // Check alreadySetup to see if the scene has been set up before. // If it is true, it means the player disconnected and reconnected to the game. // In this case, we should not spawn a new Player GameObject for the player. if (! alreadySetup ) { // If alreadySetup is false, it means the player just started the game. // We randomly select a SpawnPoint and ask the SceneSpawner to spawn a Player GameObject. // we have 1 playerPrefabs so playerPrefabIndex is 0. // We have 4 spawnPoints so we generated a random int between 0 to 3. int spawnPointIndex = Random . Range ( 0 , 3 ); NetworkClient . Instance . LastSpawner . SpawnForPlayer ( 0 , spawnPointIndex ); \u200b // Tell the spawner that we have finished setting up the scene. // alreadySetup will be true when SceneSpawn becomes ready next time. NetworkClient . Instance . LastSpawner . PlayerFinishedSceneSetup (); } } } In the SceneSpawner component, add a listener to the On Ready event. Select OnSpawnerReady(bool) in the GameSceneManager.cs script. Make sure to select the OnSpawnerReady method from the Dynamic bool section in the list..","title":"Handling the SceneSpawner OnReady Event"},{"location":"tutorials/top-down/sync-player-transform/","text":"Sync Player Transform 3 - 5 minutes read RealTime Agent Open the game scene, select the Player GameObject in the Hierarchy. Click the Add Component button and Search \"Agent\", select Realtime Agent to attach it to the Player GameObject. You will see that a NetworkID component was attached to Player GameObject automatically. NetworkID component helps SWNetwork to identify a GameObject. Set its Type to Player as the GameObject will be controlled by the players. \u200b Position The RealTimeAgent send GameObject's position, rotation updates to its remote duplicates. The Player GameObject moves in X, Y, Z directions, so we need to enable all of them. The Min , Max , and Resolution settings are used to compress the X, Y, Z values. In this game, the player moves between -20 to 20 in the X-axis, 0 to 3 in the Y-axis, and -20 to 20 in the Z-axis. You can use these limits to set the compression settings. Rotation The Player GameObject rotates around the Y-axis. We should enable Y for Rotation. We can set the resolution to Ten as we do not need high precision for rotation. The Y rotation value that remote duplicates receive will be like: 0, 10, 20 ... 360. The Interpolate field controls the interpolation of rotation and scale updates. The larger the number the faster the GameObject interpolates to the target rotation and scale. The Smooth Level field controls the smoothness of position updates. The larger the number the smoother the GameObject moves to the target position. However, a larger smooth level will affect the GameObjects responsiveness. The Read Function field controls in which function the remote duplicates will read the position updates. You can use the settings in the below screenshot to config the RealTime Agent. Updating the PlayerMovement.cs script You need to update the PlayerMovement.cs script so that only the source Player GameObject receives user inputs. Use the IsMine property of NetworkID to find out if the Player GameObject is the source GameObject. Also, set the camera to follow the source Player GameObject. The PlayerMovement.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b /// summary /// Player movement. /// /summary public class PlayerMovement : MonoBehaviour { public float moveSpeed = 6.0F ; public float gravity = - 15f ; private float verticalVelocity ; public float jumpForce = 7.0f ; \u200b private CharacterController characterController ; \u200b NetworkID networkId ; \u200b void Start () { characterController = GetComponent CharacterController (); networkId = GetComponent NetworkID (); \u200b if ( networkId . IsMine ) { // set CameraFollow target Camera m_MainCamera = Camera . main ; CameraFollow cameraFollow = m_MainCamera . GetComponent CameraFollow (); cameraFollow . target = gameObject ; } } \u200b void Update () { if ( networkId . IsMine ) { // get keyboard inputs float speedX = Input . GetAxis ( Horizontal ) * moveSpeed ; float speedZ = Input . GetAxis ( Vertical ) * moveSpeed ; \u200b if ( characterController . isGrounded ) { verticalVelocity = gravity ; if ( Input . GetKeyDown ( KeyCode . Space )) { Jump (); } } else { verticalVelocity += gravity * Time . deltaTime ; } \u200b Vector3 movement = new Vector3 ( speedX , verticalVelocity , speedZ ); characterController . Move ( movement * Time . deltaTime ); } } \u200b public void Jump () { verticalVelocity = jumpForce ; } } Updating the PlayerWeapon.cs script Make sure only the GameObject that the local player owns receives mouse movement as well. The PlayerWeapon.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b public class PlayerWeapon : MonoBehaviour { // aimable layers public LayerMask layerMask ; \u200b private Vector3 currentLookTarget = Vector3 . zero ; public Gun gun ; \u200b // launch position of bulletes public Transform launchPosition ; \u200b NetworkID networkId ; \u200b private void Start () { networkId = GetComponent NetworkID (); } \u200b void FixedUpdate () { if ( networkId . IsMine ) { // find player s cursor position in the environment RaycastHit hit ; Ray ray = Camera . main . ScreenPointToRay ( Input . mousePosition ); Debug . DrawRay ( ray . origin , ray . direction * 1000 , Color . green ); if ( Physics . Raycast ( ray , out hit , 1000 , layerMask , QueryTriggerInteraction . Ignore )) { if ( hit . point != currentLookTarget ) { currentLookTarget = hit . point ; } } \u200b // ignore cursor position s y value. Vector3 targetPosition = new Vector3 ( hit . point . x , transform . position . y , hit . point . z ); \u200b // calculate player s new rotation Quaternion rotation = Quaternion . LookRotation ( targetPosition - transform . position ); \u200b // lerp transform . rotation = Quaternion . Lerp ( transform . rotation , rotation , Time . deltaTime * 10.0f ); } } \u200b void Update () { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } \u200b void FireBullet () { gun . FireBullet ( launchPosition . position , transform . forward ); } }","title":"Sync Player Transform"},{"location":"tutorials/top-down/sync-player-transform/#sync-player-transform","text":"3 - 5 minutes read","title":"Sync Player Transform"},{"location":"tutorials/top-down/sync-player-transform/#realtime-agent","text":"Open the game scene, select the Player GameObject in the Hierarchy. Click the Add Component button and Search \"Agent\", select Realtime Agent to attach it to the Player GameObject. You will see that a NetworkID component was attached to Player GameObject automatically. NetworkID component helps SWNetwork to identify a GameObject. Set its Type to Player as the GameObject will be controlled by the players. \u200b","title":"RealTime Agent"},{"location":"tutorials/top-down/sync-player-transform/#position","text":"The RealTimeAgent send GameObject's position, rotation updates to its remote duplicates. The Player GameObject moves in X, Y, Z directions, so we need to enable all of them. The Min , Max , and Resolution settings are used to compress the X, Y, Z values. In this game, the player moves between -20 to 20 in the X-axis, 0 to 3 in the Y-axis, and -20 to 20 in the Z-axis. You can use these limits to set the compression settings.","title":"Position"},{"location":"tutorials/top-down/sync-player-transform/#rotation","text":"The Player GameObject rotates around the Y-axis. We should enable Y for Rotation. We can set the resolution to Ten as we do not need high precision for rotation. The Y rotation value that remote duplicates receive will be like: 0, 10, 20 ... 360. The Interpolate field controls the interpolation of rotation and scale updates. The larger the number the faster the GameObject interpolates to the target rotation and scale. The Smooth Level field controls the smoothness of position updates. The larger the number the smoother the GameObject moves to the target position. However, a larger smooth level will affect the GameObjects responsiveness. The Read Function field controls in which function the remote duplicates will read the position updates. You can use the settings in the below screenshot to config the RealTime Agent.","title":"Rotation"},{"location":"tutorials/top-down/sync-player-transform/#updating-the-playermovementcs-script","text":"You need to update the PlayerMovement.cs script so that only the source Player GameObject receives user inputs. Use the IsMine property of NetworkID to find out if the Player GameObject is the source GameObject. Also, set the camera to follow the source Player GameObject. The PlayerMovement.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b /// summary /// Player movement. /// /summary public class PlayerMovement : MonoBehaviour { public float moveSpeed = 6.0F ; public float gravity = - 15f ; private float verticalVelocity ; public float jumpForce = 7.0f ; \u200b private CharacterController characterController ; \u200b NetworkID networkId ; \u200b void Start () { characterController = GetComponent CharacterController (); networkId = GetComponent NetworkID (); \u200b if ( networkId . IsMine ) { // set CameraFollow target Camera m_MainCamera = Camera . main ; CameraFollow cameraFollow = m_MainCamera . GetComponent CameraFollow (); cameraFollow . target = gameObject ; } } \u200b void Update () { if ( networkId . IsMine ) { // get keyboard inputs float speedX = Input . GetAxis ( Horizontal ) * moveSpeed ; float speedZ = Input . GetAxis ( Vertical ) * moveSpeed ; \u200b if ( characterController . isGrounded ) { verticalVelocity = gravity ; if ( Input . GetKeyDown ( KeyCode . Space )) { Jump (); } } else { verticalVelocity += gravity * Time . deltaTime ; } \u200b Vector3 movement = new Vector3 ( speedX , verticalVelocity , speedZ ); characterController . Move ( movement * Time . deltaTime ); } } \u200b public void Jump () { verticalVelocity = jumpForce ; } }","title":"Updating the PlayerMovement.cs script"},{"location":"tutorials/top-down/sync-player-transform/#updating-the-playerweaponcs-script","text":"Make sure only the GameObject that the local player owns receives mouse movement as well. The PlayerWeapon.cs script should look like. using UnityEngine ; using SWNetwork ; \u200b public class PlayerWeapon : MonoBehaviour { // aimable layers public LayerMask layerMask ; \u200b private Vector3 currentLookTarget = Vector3 . zero ; public Gun gun ; \u200b // launch position of bulletes public Transform launchPosition ; \u200b NetworkID networkId ; \u200b private void Start () { networkId = GetComponent NetworkID (); } \u200b void FixedUpdate () { if ( networkId . IsMine ) { // find player s cursor position in the environment RaycastHit hit ; Ray ray = Camera . main . ScreenPointToRay ( Input . mousePosition ); Debug . DrawRay ( ray . origin , ray . direction * 1000 , Color . green ); if ( Physics . Raycast ( ray , out hit , 1000 , layerMask , QueryTriggerInteraction . Ignore )) { if ( hit . point != currentLookTarget ) { currentLookTarget = hit . point ; } } \u200b // ignore cursor position s y value. Vector3 targetPosition = new Vector3 ( hit . point . x , transform . position . y , hit . point . z ); \u200b // calculate player s new rotation Quaternion rotation = Quaternion . LookRotation ( targetPosition - transform . position ); \u200b // lerp transform . rotation = Quaternion . Lerp ( transform . rotation , rotation , Time . deltaTime * 10.0f ); } } \u200b void Update () { // get mouse inputs if ( Input . GetMouseButtonDown ( 0 )) { // 0.5 seconds interval between shots if (! IsInvoking ( FireBullet )) { InvokeRepeating ( FireBullet , 0f , 0.5f ); } } \u200b if ( Input . GetMouseButtonUp ( 0 )) { CancelInvoke ( FireBullet ); } } \u200b void FireBullet () { gun . FireBullet ( launchPosition . position , transform . forward ); } }","title":"Updating the PlayerWeapon.cs script"},{"location":"tutorials/top-down/sync-properties/","text":"SyncProperties 5 - 10 minutes read In this section, you will use SyncProperty to update player's hp. Why using SyncProperty SyncProperties are designed for updating states that are not constantly changing. Only send/receive when the property updates Reliable Supports serializable objects Supports user-defined classes and structs. Supports conflict resolution SyncPropertyAgent Select the Player Prefab. Click the Add Component button and Search \"Agent\", select Sync Property Agent to attach it to the Player GameObject. Click the Add Sync Property button to create a SyncProperty for the Player. The Property's name is important and has to be unique in the same SyncPropertyAgent component. Set Name to \"hp\" and set Type to Int . The Conflict Resolution rule is default to Mine . You can use Mine for this tutorial. For more information on Conflict Resolution, please visit [Conflict Resolution]. Updating the PlayerHP.cs Script Add two properties: networkId, and syncPropertyAgent. NetworkID networkId ; SyncPropertyAgent syncPropertyAgent ; You can remove the currentHP property as the player hp will be stored in the \"hp\" SyncProperty. In the Start() method, and initialize the networkId, and syncPropertyAgent void Start () { networkId = GetComponent NetworkID (); syncPropertyAgent = gameObject . GetComponent SyncPropertyAgent (); } Handling the OnReady SyncProperty Event public void OnHPReady () { Debug . Log ( OnHPPropertyReady ); \u200b // Get the current value of the hp SyncProperty. currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the local player has ownership of the GameObject. // Source GameObject can modify the hp SyncProperty. // Remote duplicates should only be able to read the hp SyncProperty. if ( networkId . IsMine ) { int version = syncPropertyAgent . GetPropertyWithName ( hp ). version ; \u200b if ( version != 0 ) { // You can check the version of a SyncProperty to see if it has been initialized. // If version is not 0, it means the SyncProperty has been modified before. // Probably the player got disconnected from the game. // Set hpSlider s value to currentHP to restore player s hp. hpSlider . value = currentHP ; } else { // If version is 0, you can call the Modify() method on the SyncPropertyAgent to initialize player s hp to maxHp. syncPropertyAgent . Modify ( hp , maxHp ); hpSlider . value = maxHp ; } } else { hpSlider . value = currentHP ; } } Updating the GotHit() Method public void GotHit ( int damage ) { // Only the source GameObject can modify the hp SyncProperty. if ( networkId . IsMine ) { currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the player is already dead. if ( currentHP == 0 ) { return ; } \u200b Debug . Log ( Got hit: old currentHP= + currentHP ); \u200b if ( currentHP 0 ) { currentHP = currentHP - damage ; // if hp is lower than 0, set it to 0. if ( currentHP 0 ) { currentHP = 0 ; } } \u200b Debug . Log ( Got hit: new currentHP= + currentHP ); \u200b // Apply damage and modify the hp SyncProperty. syncPropertyAgent . Modify ( hp , currentHP ); } } Handling the OnChanged SyncProperty Event public void OnHpChanged () { // Update the hpSlider when player hp changes currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); hpSlider . value = currentHP ; } Adding listeners to the \"hp\" SyncProperty . Tip Make sure you applied the changes to the Player Prefab and disabled the Player GameObject in the Hierarchy. Play You can follow the steps in the Test and Play section to test out the \"hp\" SyncProperty.","title":"SyncProperties"},{"location":"tutorials/top-down/sync-properties/#syncproperties","text":"5 - 10 minutes read In this section, you will use SyncProperty to update player's hp. Why using SyncProperty SyncProperties are designed for updating states that are not constantly changing. Only send/receive when the property updates Reliable Supports serializable objects Supports user-defined classes and structs. Supports conflict resolution","title":"SyncProperties"},{"location":"tutorials/top-down/sync-properties/#syncpropertyagent","text":"Select the Player Prefab. Click the Add Component button and Search \"Agent\", select Sync Property Agent to attach it to the Player GameObject. Click the Add Sync Property button to create a SyncProperty for the Player. The Property's name is important and has to be unique in the same SyncPropertyAgent component. Set Name to \"hp\" and set Type to Int . The Conflict Resolution rule is default to Mine . You can use Mine for this tutorial. For more information on Conflict Resolution, please visit [Conflict Resolution].","title":"SyncPropertyAgent"},{"location":"tutorials/top-down/sync-properties/#updating-the-playerhpcs-script","text":"","title":"Updating the PlayerHP.cs Script"},{"location":"tutorials/top-down/sync-properties/#add-two-properties-networkid-and-syncpropertyagent","text":"NetworkID networkId ; SyncPropertyAgent syncPropertyAgent ; You can remove the currentHP property as the player hp will be stored in the \"hp\" SyncProperty.","title":"Add two properties: networkId, and syncPropertyAgent."},{"location":"tutorials/top-down/sync-properties/#in-the-start-method-and-initialize-the-networkid-and-syncpropertyagent","text":"void Start () { networkId = GetComponent NetworkID (); syncPropertyAgent = gameObject . GetComponent SyncPropertyAgent (); }","title":"In the Start() method, and initialize the networkId, and syncPropertyAgent"},{"location":"tutorials/top-down/sync-properties/#handling-the-onready-syncproperty-event","text":"public void OnHPReady () { Debug . Log ( OnHPPropertyReady ); \u200b // Get the current value of the hp SyncProperty. currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the local player has ownership of the GameObject. // Source GameObject can modify the hp SyncProperty. // Remote duplicates should only be able to read the hp SyncProperty. if ( networkId . IsMine ) { int version = syncPropertyAgent . GetPropertyWithName ( hp ). version ; \u200b if ( version != 0 ) { // You can check the version of a SyncProperty to see if it has been initialized. // If version is not 0, it means the SyncProperty has been modified before. // Probably the player got disconnected from the game. // Set hpSlider s value to currentHP to restore player s hp. hpSlider . value = currentHP ; } else { // If version is 0, you can call the Modify() method on the SyncPropertyAgent to initialize player s hp to maxHp. syncPropertyAgent . Modify ( hp , maxHp ); hpSlider . value = maxHp ; } } else { hpSlider . value = currentHP ; } }","title":"Handling the OnReady SyncProperty Event"},{"location":"tutorials/top-down/sync-properties/#updating-the-gothit-method","text":"public void GotHit ( int damage ) { // Only the source GameObject can modify the hp SyncProperty. if ( networkId . IsMine ) { currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the player is already dead. if ( currentHP == 0 ) { return ; } \u200b Debug . Log ( Got hit: old currentHP= + currentHP ); \u200b if ( currentHP 0 ) { currentHP = currentHP - damage ; // if hp is lower than 0, set it to 0. if ( currentHP 0 ) { currentHP = 0 ; } } \u200b Debug . Log ( Got hit: new currentHP= + currentHP ); \u200b // Apply damage and modify the hp SyncProperty. syncPropertyAgent . Modify ( hp , currentHP ); } }","title":"Updating the GotHit() Method"},{"location":"tutorials/top-down/sync-properties/#handling-the-onchanged-syncproperty-event","text":"public void OnHpChanged () { // Update the hpSlider when player hp changes currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); hpSlider . value = currentHP ; }","title":"Handling the OnChanged SyncProperty Event"},{"location":"tutorials/top-down/sync-properties/#adding-listeners-to-the-hp-syncproperty","text":"Tip Make sure you applied the changes to the Player Prefab and disabled the Player GameObject in the Hierarchy.","title":"Adding listeners to the \"hp\" SyncProperty."},{"location":"tutorials/top-down/sync-properties/#play","text":"You can follow the steps in the Test and Play section to test out the \"hp\" SyncProperty.","title":"Play"},{"location":"tutorials/top-down/test-and-play/","text":"Test and Play 3 - 5 minutes read At this point, you have set up the Player prefab, configured the SceneSpawner , and updated the LobbyScene to load the Game Scene. It's time to have some fun now. Let's build the game and test out what we have created so far. Disable the Player GameObject in the Game Scene Hierarchy as we want the SceneSpawner to create the Players. Custom Player Id SWNetwork generates unique playerId for each game installation. This is for SocketWeaver to identify a client. If you call the NetworkClient.Instance.CheckIn() method, the generated playerId will be used to check the client into the SocketWeaver services. Tip The first line in the black box is the generated playerId: a9d91dbd-64... If you use services like Google Firebase to manage user profiles, you can call the NetworkClient.Instance.CheckIn(customPlayerId) method to overide the generated playerId. Tip You can use the NetworkClient.Instance.CheckIn(customPlayerId) method for development testing as well. Build and Run Select Build Settings... Make sure you have added the welcome scene and game scene to the game. The welcome scene should have index 0 . The game scene should have index 1 . Select Build to build the game. In the Game Configuration window, select the resolution and the Graphics quality you like and enable Windowed . Click on the Play! button to start the game. The game should launch to the LobbyScene. Enter \"player1\" as the custom playerId and click the Register blue button. You should see the Play button replaces the Register button indicating that you have successfully checked-in and are ready to join or create rooms. Click the Play button to join or create a room. As there is no room on the lobby server for your game, the local player \"player1\" will create a new room on the lobby server and become the owner of the new room. The matchmaking logic of the LobbyScene will automatically start the room and connect to the room game server once it is ready. The game should load the game scene now. Running another client in the Unity Editor In the Unity Editor, load the LobbyScene and hit play . Enter \"player2\" as the custom player Id and click the Register blue button. Notice the playerId in the NetworkClient is overridden by the custom playerId you entered. Click the Play blue button, the \"player2\" client will try to join or create a room. It will find the room that \"player1\" created. Since the room has already started, \"player2\" will automatically connect to the room game server and load the game scene. Now you can move around in the scene and try to find \"player1\"! Success Congratulations! You found \"player1\".","title":"Test and Play"},{"location":"tutorials/top-down/test-and-play/#test-and-play","text":"3 - 5 minutes read At this point, you have set up the Player prefab, configured the SceneSpawner , and updated the LobbyScene to load the Game Scene. It's time to have some fun now. Let's build the game and test out what we have created so far. Disable the Player GameObject in the Game Scene Hierarchy as we want the SceneSpawner to create the Players.","title":"Test and Play"},{"location":"tutorials/top-down/test-and-play/#custom-player-id","text":"SWNetwork generates unique playerId for each game installation. This is for SocketWeaver to identify a client. If you call the NetworkClient.Instance.CheckIn() method, the generated playerId will be used to check the client into the SocketWeaver services. Tip The first line in the black box is the generated playerId: a9d91dbd-64... If you use services like Google Firebase to manage user profiles, you can call the NetworkClient.Instance.CheckIn(customPlayerId) method to overide the generated playerId. Tip You can use the NetworkClient.Instance.CheckIn(customPlayerId) method for development testing as well.","title":"Custom Player Id"},{"location":"tutorials/top-down/test-and-play/#build-and-run","text":"Select Build Settings... Make sure you have added the welcome scene and game scene to the game. The welcome scene should have index 0 . The game scene should have index 1 . Select Build to build the game. In the Game Configuration window, select the resolution and the Graphics quality you like and enable Windowed . Click on the Play! button to start the game. The game should launch to the LobbyScene. Enter \"player1\" as the custom playerId and click the Register blue button. You should see the Play button replaces the Register button indicating that you have successfully checked-in and are ready to join or create rooms. Click the Play button to join or create a room. As there is no room on the lobby server for your game, the local player \"player1\" will create a new room on the lobby server and become the owner of the new room. The matchmaking logic of the LobbyScene will automatically start the room and connect to the room game server once it is ready. The game should load the game scene now.","title":"Build and Run"},{"location":"tutorials/top-down/test-and-play/#running-another-client-in-the-unity-editor","text":"In the Unity Editor, load the LobbyScene and hit play . Enter \"player2\" as the custom player Id and click the Register blue button. Notice the playerId in the NetworkClient is overridden by the custom playerId you entered. Click the Play blue button, the \"player2\" client will try to join or create a room. It will find the room that \"player1\" created. Since the room has already started, \"player2\" will automatically connect to the room game server and load the game scene. Now you can move around in the scene and try to find \"player1\"! Success Congratulations! You found \"player1\".","title":"Running another client in the Unity Editor"},{"location":"tutorials/top-down/update-room-states/","text":"Updating Room States 3 - 5 minutes read RoomPropertyAgent You have used the SyncPropertyAgent to update player properties. The RoomPropertyAgent is similar to the SyncPropertyAgent, but it is designed to update room level properties. Select the GameManager GameObject in the Scene Hierarchy, Click the Add Component Button and search for \"GameDataManager\". Select RoomPropertyAgent to Attach it to the GameManager GameObject. Similar to the SceneSpawner , a Network System ID component is attached automatically. You can have multiple RoomPropertyAgents, just make sure you assigned different Agent Id to them. Adding the \"PlayerScores\" SyncProperty Click Add Game Sync Property button and name the new SyncProperty \"PlayerScores\". Set its Type to Serializable . Rules for wining the game For this tutorial, the player who killed opponents 3 times is the winner of the game. You can use serializable objects to store player scores. GameData and PlayerScore Create a new script and call it GameDataModels.cs. Add GameData and PlayerScore Serializable Classes. using System ; using System.Collections.Generic ; \u200b [Serializable] public class PlayerScores { public List Score scores = new List Score (); } \u200b [Serializable] public class Score { public string playerRemoteId ; public int score ; } Update the GameSceneManager.cs script. It should have a reference to its RoomPropertyAgent component. RoomPropertyAgent roomPropertyAgent ; \u200b private void Start () { roomPropertyAgent = GetComponent RoomPropertyAgent (); } Add a method public void PlayerScored(string) to update the \"PlayerScores\" SyncProperty. public void PlayerScored ( string playerId ) { // Read the current value of the PlayerScores SyncProperty. PlayerScores playerScores = roomPropertyAgent . GetPropertyWithName ( PlayerScores ). GetValue PlayerScores (); \u200b // Initialize the playerScores object. if ( playerScores == null ) { playerScores = new PlayerScores (); } \u200b bool foundPlayerScore = false ; \u200b // If player already have a score, increase it by 1. foreach ( Score s in playerScores . scores ) { if ( s . playerRemoteId == playerId ) { s . score ++; foundPlayerScore = true ; } } \u200b // If player has not scored yet, add a new score for the player and set its value to 1. if (! foundPlayerScore ) { Score ps = new Score (); ps . playerRemoteId = playerId ; ps . score = 1 ; playerScores . scores . Add ( ps ); } \u200b // Modify the PlayerScores SyncProperty roomPropertyAgent . Modify PlayerScores ( PlayerScores , playerScores ); }","title":"Updating Room States"},{"location":"tutorials/top-down/update-room-states/#updating-room-states","text":"3 - 5 minutes read","title":"Updating Room States"},{"location":"tutorials/top-down/update-room-states/#roompropertyagent","text":"You have used the SyncPropertyAgent to update player properties. The RoomPropertyAgent is similar to the SyncPropertyAgent, but it is designed to update room level properties. Select the GameManager GameObject in the Scene Hierarchy, Click the Add Component Button and search for \"GameDataManager\". Select RoomPropertyAgent to Attach it to the GameManager GameObject. Similar to the SceneSpawner , a Network System ID component is attached automatically. You can have multiple RoomPropertyAgents, just make sure you assigned different Agent Id to them.","title":"RoomPropertyAgent"},{"location":"tutorials/top-down/update-room-states/#adding-the-playerscores-syncproperty","text":"Click Add Game Sync Property button and name the new SyncProperty \"PlayerScores\". Set its Type to Serializable . Rules for wining the game For this tutorial, the player who killed opponents 3 times is the winner of the game. You can use serializable objects to store player scores.","title":"Adding the \"PlayerScores\" SyncProperty"},{"location":"tutorials/top-down/update-room-states/#gamedata-and-playerscore","text":"Create a new script and call it GameDataModels.cs. Add GameData and PlayerScore Serializable Classes. using System ; using System.Collections.Generic ; \u200b [Serializable] public class PlayerScores { public List Score scores = new List Score (); } \u200b [Serializable] public class Score { public string playerRemoteId ; public int score ; } Update the GameSceneManager.cs script. It should have a reference to its RoomPropertyAgent component. RoomPropertyAgent roomPropertyAgent ; \u200b private void Start () { roomPropertyAgent = GetComponent RoomPropertyAgent (); } Add a method public void PlayerScored(string) to update the \"PlayerScores\" SyncProperty. public void PlayerScored ( string playerId ) { // Read the current value of the PlayerScores SyncProperty. PlayerScores playerScores = roomPropertyAgent . GetPropertyWithName ( PlayerScores ). GetValue PlayerScores (); \u200b // Initialize the playerScores object. if ( playerScores == null ) { playerScores = new PlayerScores (); } \u200b bool foundPlayerScore = false ; \u200b // If player already have a score, increase it by 1. foreach ( Score s in playerScores . scores ) { if ( s . playerRemoteId == playerId ) { s . score ++; foundPlayerScore = true ; } } \u200b // If player has not scored yet, add a new score for the player and set its value to 1. if (! foundPlayerScore ) { Score ps = new Score (); ps . playerRemoteId = playerId ; ps . score = 1 ; playerScores . scores . Add ( ps ); } \u200b // Modify the PlayerScores SyncProperty roomPropertyAgent . Modify PlayerScores ( PlayerScores , playerScores ); }","title":"GameData and PlayerScore"},{"location":"tutorials/top-down/win-game/","text":"Winning the Game 5 - 10 minutes read Tracking the Bullets Owner In the PlayerWeapon.cs script, update the FireBullet() method and the RemoteFire() method to send/receive the playerId of the bullet's owner. void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); msg . PushUTF8ShortString ( NetworkClient . Instance . PlayerRemoteId ); remoteEventAgent . Invoke ( fire , msg ); } \u200b public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); string ownerId = msg . PopUTF8ShortString (); gun . fireBullet ( position , direction , ownerId ); } Add a property to the Bullet.cs script to track its owner. public string ownerId ; Update its OnCollisionEnter method to pass its ownerId to the PlayerHP object. void OnCollisionEnter ( Collision collision ) { if ( collision . gameObject . tag == Player ) { PlayerHP ps = collision . gameObject . GetComponent PlayerHP (); if ( ps != null ) { ps . GotHit ( damage , ownerId ); } } \u200b foreach ( ContactPoint contact in collision . contacts ) { Debug . Log ( contact . thisCollider . name + hit + contact . otherCollider . name ); Instantiate ( explode , contact . point , Quaternion . identity ); } } Update the FireBullet() method of Gun.cs to assign the bullet's owner. public void FireBullet ( Vector3 position , Vector3 direction , string ownerId ) { GameObject bullet = Instantiate ( bulletPrefab ) as GameObject ; \u200b Bullet b = bullet . GetComponent Bullet (); b . ownerId = ownerId ; \u200b bullet . transform . position = position ; bullet . GetComponent Rigidbody (). velocity = direction * bulletSpeed ; } Score In the PlayerHP.cs script, update the GotHit() method to take the ownerId string parameter and call the PlayerScored() method of GameSceneManager.cs to update the player's score. public void GotHit ( int damage , string ownerId ) { // Only the source GameObject can modify the hp SyncProperty. if ( networkId . IsMine ) { currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the player is already dead. if ( currentHP == 0 ) { return ; } \u200b Debug . Log ( Got hit: bullet owner= + ownerId ); \u200b Debug . Log ( Got hit: old currentHP= + currentHP ); \u200b if ( currentHP 0 ) { currentHP = currentHP - damage ; \u200b // if hp is lower than 0, set it to 0. if ( currentHP 0 ) { currentHP = 0 ; } \u200b if ( currentHP == 0 ) { // call the PlayerScored() method if player hp reached 0. // GameSceneManager will update the player s score. GameSceneManager gameSceneManager = FindObjectOfType GameSceneManager (); gameSceneManager . PlayerScored ( ownerId ); } } \u200b Debug . Log ( Got hit: new currentHP= + currentHP ); \u200b // Apply damage and modify the hp SyncProperty. syncPropertyAgent . Modify ( hp , currentHP ); } } Displaying Winner and GameOver Panel In the GameSceneManager.cs script, add a method to handle the OnChanged Event for the \"PlayerScores\" SyncProperty. We look for a score that is larger than 3 and display the Winner/GameOver panel accordingly. public void OnPlayerScoresChanged () { Debug . Log ( OnPlayerScoreChanged ); PlayerScores playerScores = roomPropertyAgent . GetPropertyWithName ( PlayerScores ). GetValue PlayerScores (); Debug . Log ( playerScores ); \u200b if ( playerScores != null playerScores . scores != null ) { foreach ( Score s in playerScores . scores ) { if ( s . score = 3 ) { if ( s . playerRemoteId == NetworkClient . Instance . PlayerRemoteId ) { winnerPanel . gameObject . SetActive ( true ); } else { gameOverPanel . gameObject . SetActive ( true ); } break ; } } } } Exiting the Room Update the Exit() method in the GameSceneManager.cs script to disconnect and leave the room. The NetworkClient.Instance.DisconnectFromRoom() method disconnects the player from the game servers. All the SWNetwork GamePlay components will stop working. The NetworkClient.Lobby.LeaveRoom() method removes the player from its current room in the lobby server. public void Exit () { NetworkClient . Instance . DisconnectFromRoom (); NetworkClient . Lobby . LeaveRoom ( HandleLeaveRoom ); } \u200b void HandleLeaveRoom ( bool okay , SWLobbyError error ) { if (! okay ) { Debug . LogError ( error ); } \u200b Debug . Log ( Left room ); SceneManager . LoadScene ( lobbyScene ); } Success Congratulations! You have done the tutorial.","title":"Winning the Game"},{"location":"tutorials/top-down/win-game/#winning-the-game","text":"5 - 10 minutes read","title":"Winning the Game"},{"location":"tutorials/top-down/win-game/#tracking-the-bullets-owner","text":"In the PlayerWeapon.cs script, update the FireBullet() method and the RemoteFire() method to send/receive the playerId of the bullet's owner. void FireBullet () { SWNetworkMessage msg = new SWNetworkMessage (); msg . Push ( launchPosition . position ); msg . Push ( transform . forward ); msg . PushUTF8ShortString ( NetworkClient . Instance . PlayerRemoteId ); remoteEventAgent . Invoke ( fire , msg ); } \u200b public void RemoteFire ( SWNetworkMessage msg ) { Vector3 position = msg . PopVector3 (); Vector3 direction = msg . PopVector3 (); string ownerId = msg . PopUTF8ShortString (); gun . fireBullet ( position , direction , ownerId ); } Add a property to the Bullet.cs script to track its owner. public string ownerId ; Update its OnCollisionEnter method to pass its ownerId to the PlayerHP object. void OnCollisionEnter ( Collision collision ) { if ( collision . gameObject . tag == Player ) { PlayerHP ps = collision . gameObject . GetComponent PlayerHP (); if ( ps != null ) { ps . GotHit ( damage , ownerId ); } } \u200b foreach ( ContactPoint contact in collision . contacts ) { Debug . Log ( contact . thisCollider . name + hit + contact . otherCollider . name ); Instantiate ( explode , contact . point , Quaternion . identity ); } } Update the FireBullet() method of Gun.cs to assign the bullet's owner. public void FireBullet ( Vector3 position , Vector3 direction , string ownerId ) { GameObject bullet = Instantiate ( bulletPrefab ) as GameObject ; \u200b Bullet b = bullet . GetComponent Bullet (); b . ownerId = ownerId ; \u200b bullet . transform . position = position ; bullet . GetComponent Rigidbody (). velocity = direction * bulletSpeed ; }","title":"Tracking the Bullets Owner"},{"location":"tutorials/top-down/win-game/#score","text":"In the PlayerHP.cs script, update the GotHit() method to take the ownerId string parameter and call the PlayerScored() method of GameSceneManager.cs to update the player's score. public void GotHit ( int damage , string ownerId ) { // Only the source GameObject can modify the hp SyncProperty. if ( networkId . IsMine ) { currentHP = syncPropertyAgent . GetPropertyWithName ( hp ). GetIntValue (); \u200b // Check if the player is already dead. if ( currentHP == 0 ) { return ; } \u200b Debug . Log ( Got hit: bullet owner= + ownerId ); \u200b Debug . Log ( Got hit: old currentHP= + currentHP ); \u200b if ( currentHP 0 ) { currentHP = currentHP - damage ; \u200b // if hp is lower than 0, set it to 0. if ( currentHP 0 ) { currentHP = 0 ; } \u200b if ( currentHP == 0 ) { // call the PlayerScored() method if player hp reached 0. // GameSceneManager will update the player s score. GameSceneManager gameSceneManager = FindObjectOfType GameSceneManager (); gameSceneManager . PlayerScored ( ownerId ); } } \u200b Debug . Log ( Got hit: new currentHP= + currentHP ); \u200b // Apply damage and modify the hp SyncProperty. syncPropertyAgent . Modify ( hp , currentHP ); } }","title":"Score"},{"location":"tutorials/top-down/win-game/#displaying-winner-and-gameover-panel","text":"In the GameSceneManager.cs script, add a method to handle the OnChanged Event for the \"PlayerScores\" SyncProperty. We look for a score that is larger than 3 and display the Winner/GameOver panel accordingly. public void OnPlayerScoresChanged () { Debug . Log ( OnPlayerScoreChanged ); PlayerScores playerScores = roomPropertyAgent . GetPropertyWithName ( PlayerScores ). GetValue PlayerScores (); Debug . Log ( playerScores ); \u200b if ( playerScores != null playerScores . scores != null ) { foreach ( Score s in playerScores . scores ) { if ( s . score = 3 ) { if ( s . playerRemoteId == NetworkClient . Instance . PlayerRemoteId ) { winnerPanel . gameObject . SetActive ( true ); } else { gameOverPanel . gameObject . SetActive ( true ); } break ; } } } }","title":"Displaying Winner and GameOver Panel"},{"location":"tutorials/top-down/win-game/#exiting-the-room","text":"Update the Exit() method in the GameSceneManager.cs script to disconnect and leave the room. The NetworkClient.Instance.DisconnectFromRoom() method disconnects the player from the game servers. All the SWNetwork GamePlay components will stop working. The NetworkClient.Lobby.LeaveRoom() method removes the player from its current room in the lobby server. public void Exit () { NetworkClient . Instance . DisconnectFromRoom (); NetworkClient . Lobby . LeaveRoom ( HandleLeaveRoom ); } \u200b void HandleLeaveRoom ( bool okay , SWLobbyError error ) { if (! okay ) { Debug . LogError ( error ); } \u200b Debug . Log ( Left room ); SceneManager . LoadScene ( lobbyScene ); } Success Congratulations! You have done the tutorial.","title":"Exiting the Room"}]}